# -*- coding: utf-8 -*-
"""
/***************************************************************************
 Census
                                 A QGIS plugin
 Ce plugin permet de définir un parcours optimal sur une zone définie par l'utilisateur dasn un contexte de recensement dans des zones où les données sont moindres
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2023-06-16
        git sha              : $Format:%H$
        copyright            : (C) 2023 by Victorien OLLIVIER
        email                : victorien.ollivier@ensg.eu
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
from qgis.PyQt.QtCore import QSettings, QTranslator, QCoreApplication
from qgis.PyQt.QtGui import QIcon,QColor
from qgis.PyQt.QtWidgets import QAction, QFileDialog, QTextEdit, QDialog, QVBoxLayout, QDialogButtonBox, QLineEdit, QLabel, QMessageBox

# Initialize Qt resources from file resources.py
from .resources import *
# Import the code for the dialog
from .Census_dialog import CensusDialog
import os.path
from qgis.core import *
import processing
import networkx as nx
from networkx.algorithms import approximation
import random
from PyQt5.QtCore import QVariant
from qgis.utils import iface
import math
import numpy as np
from scipy.spatial.distance import euclidean
import tempfile
import ast

class Census:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        self.iface = iface
        self.plugin_dir = os.path.dirname(__file__)
        self.menu = self.tr(u'&Census')
        self.first_start = None
        self.actions = []

    def tr(self, message):
        return QCoreApplication.translate('Census', message)

    def add_action(self, icon_path, text, callback):
        icon = QIcon(icon_path)
        action = QAction(icon, text, self.iface.mainWindow())
        action.triggered.connect(callback)
        self.iface.addToolBarIcon(action)
        self.actions.append(action)
        return action

    def initGui(self):
        icon_path = ':/plugins/Census/icon.png'
        self.add_action(icon_path, text=self.tr(u'Census'), callback=self.run)
        self.first_start = True

    def unload(self):
        for action in self.actions:
            self.iface.removeToolBarIcon(action)

    def select_output_file(self, line_edit):
        dialog = QFileDialog()
        dialog.setFileMode(QFileDialog.ExistingFile)
        dialog.setNameFilter("Shapefile (*.shp)")
        if dialog.exec_():
            filenames = dialog.selectedFiles()
            if filenames:
                filename = filenames[0]
                line_edit.setText(filename)
                
    def select_output_raster(self, line_topo):
        dialog = QFileDialog()
        dialog.setFileMode(QFileDialog.ExistingFile)
        if dialog.exec():
            filenames = dialog.selectedFiles()
            if filenames:
                filename = filenames[0]
                line_topo.setText(filename)

    def select_folder(self, line_edit_doss):
        folder_path = QFileDialog.getExistingDirectory(self.dlg, "Sélectionner un dossier", ".")
        if folder_path:
            line_edit_doss.setText(folder_path)
            self.dossier_selectionne = folder_path
            
    def run(self):
        if self.first_start:
            self.first_start = False
            self.dlg = CensusDialog()

            self.dlg.pushShpRoads.clicked.connect(lambda: self.select_output_file(self.dlg.lineShpRoads))
            self.dlg.pushShpHydro.clicked.connect(lambda: self.select_output_file(self.dlg.lineShpHydro))
            self.dlg.pushShpZone.clicked.connect(lambda: self.select_output_file(self.dlg.lineShpZone))
            self.dlg.pushTopo.clicked.connect(lambda: self.select_output_raster(self.dlg.lineTopo))
            self.dlg.getOutFile.clicked.connect(lambda: self.select_folder(self.dlg.lineOutFile))
        # show the dialog
        self.dlg.show()
        # Run the dialog event loop
        result = self.dlg.exec_()
        # See if OK was pressed
        if result:
            shp_roads_path = self.dlg.lineShpRoads.text()
            shp_hydro_path = self.dlg.lineShpHydro.text()
            shp_zone_path = self.dlg.lineShpZone.text()
            raster_topo_path = self.dlg.lineTopo.text()
            
            # Check shapefile validity
            if not self.is_valid_shapefile(shp_roads_path):
                return
            if not self.is_valid_shapefile(shp_hydro_path):
                return
            if not self.is_valid_shapefile(shp_zone_path):
                return
            zone_layer = QgsVectorLayer(shp_zone_path, "Zone", "ogr")
            id_de_ite = 0
            for feature in zone_layer.getFeatures():
                geometry = feature.geometry()

                # Créer une nouvelle couche vectorielle pour le polygone en cours
                new_layer = QgsVectorLayer("Polygon?crs=epsg:4326", "Polygone", "memory")
                
                # Ouvrir un éditeur d'entités pour la nouvelle couche
                new_layer.startEditing()
                
                # Créer une nouvelle entité pour la nouvelle couche
                new_feature = QgsFeature()
                new_feature.setGeometry(geometry)
                
                # Ajouter l'entité à la nouvelle couche
                new_layer.addFeature(new_feature)

                # Valider les modifications de la couche
                new_layer.commitChanges()
                temp_dir = tempfile.gettempdir()
                temp_file = os.path.join(temp_dir, f"temp_layer_{feature.id()}.shp")

                # Enregistrer la couche temporaire sur le disque
                QgsVectorFileWriter.writeAsVectorFormat(new_layer, temp_file, "utf-8", new_layer.crs(), "ESRI Shapefile")


                #print("mon chemin est : ",temp_file)
                
            
                self.process_shapefiles(shp_roads_path, shp_hydro_path, temp_file,raster_topo_path, id_de_ite)
                id_de_ite +=1

    def is_valid_shapefile(self, shp_path):
        layer = QgsVectorLayer(shp_path, "Validation Layer", "ogr")
        if not layer or not layer.isValid():
            QMessageBox.warning(
                self.iface.mainWindow(),
                "Validation Error",
                "The file \"%s\" is not a valid shapefile." % shp_path.replace(':', os.sep)
                )
            return False
        return True
    

    def process_shapefiles(self, shp_roads_path, shp_hydro_path, shp_zone_path,raster_topo_path,id_en_question): # FINAL
        """
        Fonction qui prend en entrée les chemins d'accès aux couches sélectionnées, un identifiant de secteur de dénombrement,
        et qui lance le processus du plugin : c'est l'équivalent d'un main.
        

        Parameters
        ----------
        shp_roads_path : String
            Chemin d'accès à la couche routes
        shp_hydro_path : String
            Chemin d'accès à la couche hydrographie
        shp_zone_path : String
            Chemin d'accès à la couche zone
        id_en_question : int
            Identifiant du secteur de dénombrement

        Returns
        -------
        couche_iti : Il s'agit de l'itinéraire créé pour le secteur de dénombrement.

        """
        # Id du secteur de dénombrment
        
        idcouche = id_en_question
        
        # On appelles les fonctions
        
        Z_layer, R_layer, H_layer = self.reduction_donnees_au_necessaire(shp_roads_path,shp_hydro_path,shp_zone_path)
        hydro_topo = self.plot_couches_entrees(shp_roads_path,shp_hydro_path,shp_zone_path,raster_topo_path)
        T_layer_global = self.explosion_des_routes(R_layer,idcouche)
        T_layer = T_layer_global[0]
        arretes = self.creation_arrete(T_layer)
        G_zone = self.creation_graphe(arretes)
        initialisation_nodess = self.get_first_node(self.dlg.adresse.text())
        initialisation_node= initialisation_nodess[idcouche]
        
        # Disjonction de cas : connexité du graphe pour savoir si on fait plusieurs itinéraires sur un même secteur ou non.
        if type(G_zone) == nx.Graph:
            itineraire, solution = self.meilleur_glouton(G_zone, int(self.dlg.iteration.text()),initialisation_node)
            clean_parcours_zone = self.coordonnees_formatees(itineraire)
        
            first_tri = self.iti_petit_grand_tri(clean_parcours_zone)
            apres_premier_rattachement = self.iti_mignon_oust(G_zone, first_tri[1], first_tri[2])
            remise_en_forme = self.reformatage(apres_premier_rattachement)
            
            # Disjonction de cas en fonction de la taille de l'itinéraire (si jamais il est un bout dès le début).
            if remise_en_forme == 0:
                couche_finish = self.extraction_tuple(first_tri[0])
                turn = self.indications(couche_finish)
                couche_iti = self.plot_arrow_polyline(couche_finish, turn)
            else:
                snake = []
                prelast_iti = self.multiples_to_one(G_zone, remise_en_forme, snake, remise_en_forme[0])
                last_iti = self.add_start_line(first_tri[0],prelast_iti)
                couche_finish = self.extraction_tuple(last_iti)
                turn = self.indications(couche_finish)
                couche_iti = self.plot_arrow_polyline(couche_finish,turn)
            
            return couche_iti
        
        elif type(G_zone) == list:
            for sous_graphe in G_zone:
                itineraire, solution = self.meilleur_glouton(sous_graphe, int(self.dlg.iteration.text()),initialisation_node)
                clean_parcours_zone = self.coordonnees_formatees(itineraire)
                first_tri = self.iti_petit_grand_tri(clean_parcours_zone)
                
                apres_premier_rattachement = self.iti_mignon_oust(sous_graphe, first_tri[1], first_tri[2])
                remise_en_forme = self.reformatage(apres_premier_rattachement)
                if remise_en_forme == 0:
                    couche_finish = self.extraction_tuple(first_tri[0])
                    turn = self.indications(couche_finish)
                    couche_iti = self.plot_arrow_polyline(couche_finish, turn)
                else:
                    snake = []
                    prelast_iti = self.multiples_to_one(sous_graphe, remise_en_forme, snake, remise_en_forme[0])
                    last_iti = self.add_start_line(first_tri[0],prelast_iti)
                    couche_finish = self.extraction_tuple(last_iti)
                    turn = self.indications(couche_finish)
                    couche_iti = self.plot_arrow_polyline(couche_finish, turn)

            return couche_iti          
     
    def plot_couches_entrees(self,shp_roads_path, shp_hydro_path, shp_zone_path,raster_topo_path): # FINAL
        """
        Fonction qui prend en entrée les chemins d'accès aux couches sélectionnées
        par l'utilisateur et qui les représente sur QGIS, pour l'hydrographie et la topographie.

        Parameters
        ----------
        shp_roads_path : String
            Chemin d'accès à la couche routes
        shp_hydro_path : String
            Chemin d'accès à la couche hydrographie
        shp_zone_path : String
            Chemin d'accès à la couche zone

        Returns
        -------
        Nothing : Il s'agit juste d'une fonction de visualisation

        """
        #Représentation de l'hydrographie
        
        hydro_layer = QgsVectorLayer(shp_hydro_path, "Hydrographie", "ogr") # On créé une couche vectorielle
        QgsProject.instance().addMapLayer(hydro_layer) # On ajoute à cette couche les données sur l'hydrographie
        
        # On construit la bbox du polygone
        polygone_layer = QgsVectorLayer(shp_zone_path, "Zone", "ogr")
        for feature in polygone_layer.getFeatures():
            polygone_bbox = feature.geometry().boundingBox()
            xMin = polygone_bbox.xMinimum()
            yMin = polygone_bbox.yMinimum()
            xMax = polygone_bbox.xMaximum()
            yMax = polygone_bbox.yMaximum()
            string_bbox = str(xMin) + ',' + str(xMax) +','+ str(yMin) + ',' + str(yMax) + ' [EPSG:4326]'
        
        #Représentation de la topographie
        
        # Predecoupage : on récupère les données topographique sur l'emprise de la zone
        emprise = processing.run("gdal:cliprasterbyextent", {
            'INPUT':raster_topo_path,
            'PROJWIN':string_bbox,
            'OVERCRS':False,
            'NODATA':None,
            'OPTIONS':'',
            'DATA_TYPE':0,
            'EXTRA':'',
            'OUTPUT':'TEMPORARY_OUTPUT'
            })
        
        emprise_path = emprise['OUTPUT']
        test_emprise = QgsRasterLayer(emprise_path, "MNT_contour", "gdal") # On créé une couche raster
        QgsProject.instance().addMapLayer(test_emprise) # On ajoute le MNT (seulement sur l'emprise)
        
        # On récupère maintenant les contours (lignes de niveaux)
        creation_contour = processing.run("gdal:contour", {
            'INPUT':emprise_path,
            'BAND':1,
            'INTERVAL': 0.5,
            'FIELD_NAME':'ELEV',
            'CREATE_3D':False,
            'IGNORE_NODATA':False,
            'NODATA':None,
            'OFFSET':0,
            'EXTRA':'',
            'OUTPUT':'TEMPORARY_OUTPUT'
            })
        
        contour_raster_path = creation_contour['OUTPUT']
        cut_result_topo = processing.run("native:clip", {
            'INPUT':contour_raster_path,
            'OVERLAY':shp_zone_path,
            'OUTPUT':'TEMPORARY_OUTPUT'})
        
        cut_topo_layer = cut_result_topo['OUTPUT']
        QgsProject.instance().addMapLayer(cut_topo_layer) # On ajoute les lignes de niveaux au projet

    def reduction_donnees_au_necessaire(self, shp_roads_path, shp_hydro_path, shp_zone_path): # FINAL
        """
        Fonction qui récupère les données du réseau routier et de l'hydrographie au sein du
        secteur de dénombrement en question.
        

        Parameters
        ----------
        shp_roads_path : String
            Chemin d'accès de la couche route.
        shp_hydro_path : String
            Chemin d'accès de la couche hydrographique.
        shp_zone_path : String
            Chemin d'accès de la couche d'un secteur de dénombrement de la zone étudiée.

        Returns
        -------
        zone_layer : QgsVectorLayer
            Couche QGIS du secteur de dénombrement.
        result_road_layer : QgsVectorLayer
            Couche  QGIS des routes sur ce secteur.
        result_hydro_layer : QgsVectorLayer
            Couche QGIS de l'hydrographie sur ce secteur.

        """
    
        zone_layer = QgsVectorLayer(shp_zone_path, "Zone", "ogr")
        roads_layer = QgsVectorLayer(shp_roads_path, "Routes", "ogr")
        hydro_layer = QgsVectorLayer(shp_hydro_path, "Hydrographie", "ogr")
        intersection_result = processing.run("native:intersection", {
            'INPUT': shp_roads_path,
            'OVERLAY': shp_zone_path,
            'INPUT_FIELDS': [],
            'OVERLAY_FIELDS': [],
            'OVERLAY_FIELDS_PREFIX': '',
            'OUTPUT': 'TEMPORARY_OUTPUT',
            'GRID_SIZE': None
        })
        result_road_layer = intersection_result['OUTPUT']
        
        intersection_result_hydro = processing.run("native:intersection", {
            'INPUT': shp_hydro_path,
            'OVERLAY': shp_zone_path,
            'INPUT_FIELDS': [],
            'OVERLAY_FIELDS': [],
            'OVERLAY_FIELDS_PREFIX': '',
            'OUTPUT': 'TEMPORARY_OUTPUT',
            'GRID_SIZE': None
        })
        result_hydro_layer = intersection_result_hydro['OUTPUT']
        
        #QgsProject.instance().addMapLayer(result_hydro_layer)
        QgsProject.instance().addMapLayer(zone_layer)
        #QgsProject.instance().addMapLayer(result_road_layer)
        return zone_layer, result_road_layer, result_hydro_layer

    def explosion_des_routes(self, road_layer, idcouche): # FINAL
        """
        Fonction qui permet de passer des entités "routes" aux tronçons qui les composent,
        et donc de prendre en compte la totalité des noeuds nécessaires à la modélisation
        du réseau en graphe, prenant en compte les interesections de routes non
        explicites dans les données "routes"

        Parameters
        ----------
        road_layer : QgsVectorLayer
            Couche QGIS qui stocke toutes les données routières 
        idcouche : int
            Identifiant du secteur de dénombrement au sein de la zone entrée par l'utilisateur

        Returns
        -------
        features_troncons : Features
            Tous les tronçons de routes, sous forme de Features (attributs) QGIS
        explode_layer : QgsVectorLayer
            Couche QGIS qui stocke tous les tronçons de chaque route.

        """
        idlayer = str(idcouche)
        
        # Spécifie le chemin vers le fichier de sortie pour les lignes explosées, à demander à l'utilisateur.
        part1 = str(self.dossier_selectionne)
        part2 = 'la_couche_sortie'
        part3 = idlayer
        part4 = '.shp'
        #output_layer = 'C:/Users/Myriam/Documents/PLUGIN_QGIS_CORRECT/donnees_crees/la_couche_sortie'+idlayer+'.shp'

        output_layer = part1 + part2 + part3 + part4
        # Utilisation du processing pour exploser les lignes
        parameters = {'INPUT': road_layer, 'OUTPUT': output_layer, 'OVERWRITE': True}
        processing.run('qgis:explodelines', parameters)

        # Création et représentation de la couche des routes explosées sur QGIS
        explode_layer = QgsVectorLayer(output_layer, "Troncons", "ogr")
        QgsProject.instance().addMapLayer(explode_layer)

        # Récupération des features de la couche, sortie
        features_troncons = explode_layer.getFeatures()
        
        return features_troncons, explode_layer
    
    def creation_arrete(self, troncons): # FINAL
        """
        Fonction qui prend en entrée les tronçons du réseau routier et qui ramène
        les arretes nécessaires, afin que chaque arrete représente une portion de route,
        mais que l'on puisse prendre en compte les intersections dans le graphe.

        Parameters
        ----------
        troncons : features
            Features de la couche QGIS qui stocke toutes les troncons 

        Returns
        -------
        arretes : list
            Liste de deux tuples, paire de noeud.

        """
        # On instancie une liste et un compteur
        arretes = []
        id1 = 0
        
        # Boucle de tri pour conserveruniquement les noeuds de départ, d'arrivée et d'intersection des routes. 
        for feature in troncons:
            geometry = feature.geometry()
            multi_line = geometry.asMultiPolyline()
            id1 = feature.attribute("osm_id")
            id2 = 0
            for line in multi_line:
                start_point = [line[0][0], line[0][1], feature.id()]
                end_point = [line[-1][0], line[-1][1], feature.id()]
                id2 = id2 + 1
                formatted_line = [start_point, end_point,id1,id2]
                # On stocke nos arretes dans une liste
                arretes.append(formatted_line)
        
        return arretes
    
    def creation_graphe(self, arretes_de_zone): # FINAL
        """
        Fonction qui prend en entrée les arretes qui représentent le réseau routier au mieux, et
        qui ressort un graphe, une modélisation avec noeuds (nodes) et arretes (edges)

        Parameters
        ----------
        arretes_de_zone : liste
            Liste de liste de tuples, qui sont les arretes (paires de noeuds)

        Returns
        -------
        G : networkx.graph
            Le graphe qui modélise le réseau routier.

        """
        
        # Initialisation d'un graphe
        G = nx.Graph()
        target_crs = QgsCoordinateReferenceSystem('EPSG:32632')  # Exemple: UTM Zone 32N, correspondant au Nigeria

        # Création de l'objet QgsCoordinateTransform pour la transformation des coordonnées
        transform = QgsCoordinateTransform(QgsCoordinateReferenceSystem('EPSG:4326'), target_crs, QgsProject.instance())
        
        # Construction du graphe et remplissage
        for start_point, end_point, id1, id2 in arretes_de_zone:
            start_node = tuple(start_point[:2])
            end_node = tuple(end_point[:2])
            edge_label = f"{id1}_{id2}"  # Étiquette de l'arête
            start_point_proj = transform.transform(QgsPointXY(start_node[0], start_node[1]))
            end_point_proj = transform.transform(QgsPointXY(end_node[0], end_node[1]))
            distance = start_point_proj.distance(end_point_proj)
            # Ajout des nœuds et l'arête au graphe
            G.add_node(start_node)
            G.add_node(end_node)
            G.add_edge(start_node, end_node, label=edge_label, weight=distance)

        # Identification des nœuds inutiles
        modified = True
        
        while modified:
            modified = False
            
            for node in list(G.nodes()):
                neighbors = list(G.neighbors(node))
                
                if len(neighbors) == 2:
                    arretes_voisines = []
                    poids = []
                    for voisin in neighbors:
                        edge_label = G.edges[node, voisin]['label']
                        arretes_voisines.append(edge_label)
                        edge_point = G.edges[node,voisin]['weight']
                        poids.append(edge_point)
                    label1 = arretes_voisines[0]
                    label2 = arretes_voisines[1]
                    
                    if label1 == label2:
                        
                        # On définit le nouveau poids
                        weight_redefini = sum(poids)
                
                        # On retire les noeuds inutiles et on reconstruit l'arrete.
                        G.remove_node(node)
                        G.add_edge(neighbors[0], neighbors[1], label=label1, weight=weight_redefini) #attention, le poids devra etre une pondération
                        modified = True
                        break
        testkm = []
        for start_node, end_node, edge_data in G.edges(data=True):
            weight = edge_data['weight']
            testkm.append(weight)
            
        # Test
        #print("la taille du graphe en mètre : ", sum(testkm))
        
        # On vérifie si le graphe est connexe ou non. S'il ne l'est pas, S'il ne l'est pas, on ne peut pas passer sur toutes les routes sur la même zone, il faut plusieurs itinéraires.
        is_connected = nx.is_connected(G)
        
        if is_connected:
            return G
            #print("Le graphe est complètement connecté.")
        else:
            G_si_plusieurs = []
            #print("Le graphe n'est pas complètement connecté.")
            components = nx.connected_components(G)
            for component in components:
                subgraph = G.subgraph(component)
                G_si_plusieurs.append(subgraph)
                num_nodes = subgraph.number_of_nodes()
                num_edges = subgraph.number_of_edges()
    
                print(f"Sous-graphe : Nombre de nœuds = {num_nodes}, Nombre d'arêtes = {num_edges}")

            return G_si_plusieurs

    def chemin_optimal(self, graph,passed_edges,passed_nodes, nombre_true,poids_total_parcouru, noeud_depart): # FINAL
        """
        Fonction qui implémente un algorithme glouton, qui construit des itinéraire. L'algorithme est "aveugle"
        et raisonne donc sur une logique de PPV, avec une considération des poids et du statut des arêtes voisines
        d'un noeud. Il s'agit d'un algorithme récursif, qui créé donc plusieurs itinéraires optimaux.

        Parameters
        ----------
        graph : networkx.graph
            Graphe modélisant le réseau routier de la zone étudiée.
        passed_edges : list
            Liste d'arêtes, qui construisent l'itinéraire (dès que l'on passe par une arête, elle est ajoutée à cette liste)
        passed_nodes : liste
            Liste de noeuds, idem que passed_edges
        nombre_true : int
            Nombred'arêtes avec le statut "visited"
        poids_total_parcouru : int
            Poids total parcouru au cours de l'itinéraire
        noeud_depart : networkx.nodes
            Noeud de départ, peut être aléatoire ou choisi à l'initialisation, est aléatoire parmi les noeuds non-visités lors de la récursivité.

        Returns
        -------
        passed_edges : list
            Liste d'arêtes, qui construisent l'itinéraire (dès que l'on passe par une arête, elle est ajoutée à cette liste)
        poids_total_parcouru : int
            Poids total parcouru au cours de l'itinéraire

        """
        nombre_edges = graph.number_of_edges() # On récupère le nombre d'arêtes du graphe
        if nombre_true >= nombre_edges:# Condition d'arrêt : toutes les arêtes sont visitées. 
            return passed_edges, poids_total_parcouru
        liste_noeuds_libres = []
        
        for node in list(graph.nodes()):
            neighbors = list(graph.neighbors(node))
            for voisin in neighbors:    
                if graph.edges[node, voisin]['Visited'] == False:
                    liste_noeuds_libres.append(node)
                    break
        if noeud_depart == 0:
            if len(liste_noeuds_libres) > 0:
                k = len(liste_noeuds_libres) - 1
                nombre_aleatoire = random.randint(0, k)
                start_node = liste_noeuds_libres[nombre_aleatoire]
                passed_nodes.append(start_node)
            else:
                print("ERROR")
        else:
            start_node = noeud_depart
            
            
        graph.nodes[start_node]['Visited'] = True
        

        passed_nodes.append(start_node)
        
        # Tant que on a pas tout parcouru une fois, on continue
        while nombre_true < nombre_edges:

            noeud_ou_nous_sommes = passed_nodes[-1]
            
            voisins_du_noeud_ou_nous_sommes = list(graph.neighbors(noeud_ou_nous_sommes))
            
            if len(voisins_du_noeud_ou_nous_sommes) == 1:
                #DEGREE 1
                # Dans ce cas de figure, on est en bout d'arrete et il n'y a pas de voisins, il faut faire demi-tour
                
                noeud_suivant = voisins_du_noeud_ou_nous_sommes[0]
                
                graph.nodes[noeud_suivant]['Visited'] = True
                if graph.edges[noeud_ou_nous_sommes,noeud_suivant]['Visited'] ==False:
                    nombre_true +=1
                    graph.edges[noeud_ou_nous_sommes,noeud_suivant]['Visited'] =True
                else:
                    graph.edges[noeud_ou_nous_sommes,noeud_suivant]['Visited'] =True
                poids_total_parcouru += graph.edges[noeud_ou_nous_sommes,noeud_suivant]['weight']
                passed_nodes.append(noeud_suivant)
                passed_edges.append((noeud_ou_nous_sommes, noeud_suivant))
            
            else:
                arretes_pas_visites=[]
            
                for noeud in voisins_du_noeud_ou_nous_sommes:
                    arrete = graph.edges[(noeud_ou_nous_sommes,noeud)]
                    if arrete['Visited'] == False:
                        arretes_pas_visites.append([arrete, noeud_ou_nous_sommes, noeud])
                
                if len(arretes_pas_visites)>=2 :
                    #DEGREE 1
                    poids = []
                    for arrete in arretes_pas_visites:
                        poids.append(arrete[0]['weight'])
                    idx_min_poids = poids.index(min(poids))
                    arrete_plus_petit_poids = arretes_pas_visites[idx_min_poids]
                    noeud1 = arrete_plus_petit_poids[1]
                    noeud2 = arrete_plus_petit_poids[2]
                    noeud_suivant = noeud2
                    graph.nodes[noeud_suivant]['Visited'] = True
                    graph.edges[noeud1, noeud_suivant]['Visited'] = True
                    nombre_true+=1
                    poids_total_parcouru += graph.edges[noeud1,noeud_suivant]['weight']
                        
                    passed_nodes.append(noeud_suivant)
                    passed_edges.append((noeud1, noeud_suivant))
                    
                elif len(arretes_pas_visites) == 1 :
                    arrete = arretes_pas_visites[0]
                    
                    noeud1 = arrete[1]
                    noeud2 = arrete[2]
                    
                    noeud_suivant = noeud2
                    graph.nodes[noeud_suivant]['Visited'] = True
                    graph.edges[noeud1, noeud_suivant]['Visited'] = True
                    
                    passed_nodes.append(noeud_suivant)
                    passed_edges.append((noeud1, noeud_suivant))
                    nombre_true+=1
                    poids_total_parcouru += graph.edges[noeud1,noeud_suivant]['weight']
                        
                
                else:
                    #On est dans la situation suivante : il y a plus d'un voisin. Ils sonttous visités
                    #print("cas pas facile en approche")
                    
                    liste_noeuds_voisins_libres = []
                    for noeud in voisins_du_noeud_ou_nous_sommes:
                        
                     #   print("ok, on rentre dans la boucle 158")
                      #  arrete_visitees = graph.edges[(noeud_ou_nous_sommes,noeud)]
                        les_voisins_du_voisin = list(graph.neighbors(noeud))
                      #  print("les voisins du voisin", les_voisins_du_voisin)
                        for voisinvoisin in les_voisins_du_voisin:
                       #     print("on cherche si les arretes sont false a degree 2")
                            if graph.edges[noeud, voisinvoisin]['Visited'] == False:
                                edge_cas_degree_deux = graph.edges[(noeud_ou_nous_sommes,noeud)]
                                liste_noeuds_voisins_libres.append([edge_cas_degree_deux,noeud_ou_nous_sommes, noeud])
                        #        print("la liste est elle remplie ?", liste_noeuds_voisins_libres)
                                
                    
                    if len(liste_noeuds_voisins_libres) > 0:
                        #print("bon alors ca arrive !")
                        arrete = liste_noeuds_voisins_libres[0]
                     #   print("arretes  l123 : ", arrete)
                        
                        noeud1 = arrete[1]
                        noeud2 = arrete[2]
                        
                        noeud_suivant = noeud2
                        graph.nodes[noeud_suivant]['Visited'] = True
                        graph.edges[noeud1, noeud_suivant]['Visited'] = True
                        
                        passed_nodes.append(noeud_suivant)
                        passed_edges.append((noeud1, noeud_suivant))
                        poids_total_parcouru += graph.edges[noeud1,noeud_suivant]['weight']
                    
                    else :
                        liste_noeuds_voisins_voisins_libres = []
                        for noeud in voisins_du_noeud_ou_nous_sommes:
                            les_voisins_du_voisin = list(graph.neighbors(noeud))
                            for cousin in les_voisins_du_voisin:
                                cousincousin = list(graph.neighbors(cousin))
                                for indiv in cousincousin:
                                    if graph.edges[cousin, indiv]['Visited'] == False:
                                        edges_cas_degree_trois = graph.edges[(noeud_ou_nous_sommes, noeud)]
                                        liste_noeuds_voisins_voisins_libres.append([edges_cas_degree_trois,noeud_ou_nous_sommes,noeud])
                        
                        
                        if len(liste_noeuds_voisins_voisins_libres) > 0:
                            arrete = liste_noeuds_voisins_voisins_libres[0]
                            noeud1 = arrete[1]
                            noeud2 = arrete[2]
                            noeud_suivant = noeud2
                            graph.nodes[noeud_suivant]['Visited'] = True
                            graph.edges[noeud1, noeud_suivant]['Visited'] = True
                            passed_nodes.append(noeud_suivant)
                            passed_edges.append((noeud1, noeud_suivant))
                            poids_total_parcouru += graph.edges[noeud1,noeud_suivant]['weight']
                            
                        
                        else:
                            liste_noeuds_voisin_degre4 = []
                            for noeud in voisins_du_noeud_ou_nous_sommes:
                                les_voisins_du_voisins = list(graph.neighbors(noeud))
                                for cousin in les_voisins_du_voisins:
                                    cousincousin = list(graph.neighbors(cousin))
                                    for indiv in cousincousin:
                                        voisinsdeg4 = list(graph.neighbors(indiv))
                                        for individu in voisinsdeg4:
                                            if graph.edges[indiv,individu]['Visited'] ==False:
                                                edges_cas_degree_quatre = graph.edges[(noeud_ou_nous_sommes, noeud)]
                                                liste_noeuds_voisin_degre4.append([edges_cas_degree_quatre,noeud_ou_nous_sommes,noeud])
                            if len(liste_noeuds_voisin_degre4) > 0:
                                arrete = liste_noeuds_voisin_degre4[0]
                                noeud1 = arrete[1]
                                noeud2 = arrete[2]
                                noeud_suivant = noeud2
                                graph.nodes[noeud_suivant]['Visited'] = True
                                graph.edges[noeud1, noeud_suivant]['Visited'] = True
                                passed_nodes.append(noeud_suivant)
                                passed_edges.append((noeud1, noeud_suivant))
                                poids_total_parcouru += graph.edges[noeud1,noeud_suivant]['weight']
                                
                            else:
                                # Récursivité : il n'y a aucune arête assez à proximité, on relance l'algorithme à partir d'un autre point. 
                                return self.chemin_optimal(graph, passed_edges,passed_nodes, nombre_true,poids_total_parcouru, 0)
        return passed_edges, poids_total_parcouru
    
    def tri_itineraires(self,chemin): # FINAL
        """
        Fonction qui permet de passer des paires de noeuds à des polylignes

        Parameters
        ----------
        chemin : list
            Liste dont les données sont organisées en paires de noeuds (pour chaque arête) 

        Returns
        -------
        les_chemins : list
            Liste qui fonctionne en terme de noeuds, pas en paires. C'est une polyligne. 

        """
        
        les_chemins = []  # Liste pour stocker les itinéraires
        chemin_temporaire = []  # Liste temporaire pour un itinéraire courant

        for troncon in chemin:
            if len(chemin_temporaire) == 0:
                chemin_temporaire.append(troncon)
            else:
                dernier_troncon = chemin_temporaire[-1]
                noeud_fin_dernier = dernier_troncon[1]
                noeud_debut_actuel = troncon[0]

                if noeud_fin_dernier == noeud_debut_actuel:
                    chemin_temporaire.append(troncon)
                else:
                    les_chemins.append(chemin_temporaire)
                    chemin_temporaire = [troncon]

        if len(chemin_temporaire) > 0:
            les_chemins.append(chemin_temporaire)

        return les_chemins
    
    def meilleur_glouton(self,G,nombre_de_relance, init_node): # FINAL
        """
        Fonction qui permet de lancer l'algorithme glouton (chemin_optimal, tri_itineraires) plusieurs fois et de comparer les
        résultats de chacun pour choisir le plus optimal.

        Parameters
        ----------
        G : networkx.graph
            graphe modélisant le réseau routier.
        nombre_de_relance : int
            Nombre de fois que l'utilisateurs souhaite lancer l'algorithme glouton. 
        init_node : networkx.node()
            Noeud de départ choisi par l'utilisateur pour le secteur de dénombrement en question.

        Returns
        -------
        itineraire_final : list
            Liste avec chaque itinéraire construit, sous forme de polyligne
        solution : list
            Liste avec chaque itinéraire construit, sous forme de liste de paires de noeuds, de polylignes, avec le nombre d'itinéraires, le coût total parcouru, l'indice d'optimalité.
        """
        liste_infos_pour_chaque_iti = []
        
        distance = 100
        potential_node = None

        for node in list(G.nodes()):
            distance_entre_points = euclidean(np.array(node), np.array(init_node))
            if distance_entre_points < distance:
                distance = distance_entre_points
                potential_node = node
        
        for i in range(nombre_de_relance): # On réalise n fois le protocole suivant :
            
            # Initialisation 
            nx.set_node_attributes(G, False, 'Visited')
            nx.set_edge_attributes(G, False, 'Visited')
            poids_total_parcouru = 0
            noeud_depart = potential_node # On initialise un noeud de départ. Il est ici au hasard, il peut être demandé à l'utilisateur.
            passed_edges = []
            passed_nodes = []
            nombre_true = 0
            
            # Lancement des algorithmes de parcourt optimal
            A = self.chemin_optimal(G, passed_edges,passed_nodes,nombre_true,poids_total_parcouru, noeud_depart)
            B = self.tri_itineraires(A[0])
            nombre_iti = len(B) # On récupère le nombre d'itinéraires créés lors de l'itération. 
            poids_de_la_relance = A[1] # On récupère le poids total parcour lors de l'itération.

            # Définition de l'indice d'optimalité, qu'on souhaite minimiser.
            alpha = 0.85
            beta = 0.15
            indice_optimalite = alpha * nombre_iti + beta * poids_de_la_relance
            liste_infos_pour_chaque_iti.append([A, B, nombre_iti, poids_de_la_relance, indice_optimalite])
        
        # On cherche l'itinéraire qui a l'indice d'optimalité le plus faible, c'est-à-dire qui minimise le nombre de portions d'itinéraire, ainsi que le coût total. 
        R_min = []
        for iti_possible in liste_infos_pour_chaque_iti:
            R_min.append(iti_possible[-1])
        
        minimum = min(R_min)
        index_minimum = R_min.index(minimum)
        
        # On prépare le return, qui ressort les informations sur le meilleur itinéraire. 
        solution = liste_infos_pour_chaque_iti[index_minimum]
        # Test
        #print("le nombre de metres parcouru est : ", solution[3])
        itineraire_final = solution[1]
        
        testkm=[]
        for start_node, end_node, edge_data in G.edges(data=True):
            weight = edge_data['weight']
            testkm.append(weight)
            
        # Test
        print("la taille du graphe en mètre : ", sum(testkm))
        # Pour étudier la qualité du trajet en fonction du nombre d'intérations
        print("le nombre de noeud est : ", G.number_of_nodes())
        print("le nombre d'arêtes est : ", G.number_of_edges())
        print("l'indice d'optimalité a une valeur de : ", solution[4])
        print("Combien d'itinéraires on été créés  ? : ", solution[2])
        print("La distance parcourue est : ", solution[3])
        print("----------------------------------------------")
        
        return itineraire_final, solution
    
    def coordonnees_formatees(self,solution): # FINAL
        """
        Fonction qui prend en entrée les arretes des itinéraires optimaux et qui les formate pour préparer
        un premier rattachement (par le biais d'une distinction entre les petits et grands itinéraires).

        Parameters
        ----------
        solution : list
            Liste en bazard des itinéraires optimaux. 

        Returns
        -------
        coordinates_propre : list
            Liste propre de ce qui va permettre de les classer entre petits et grands itinéraires. 

        """
        # Test
        #print("coordonnées formatées ", solution)
        coordinates_propre = []
        for iti in solution :
            iti_propre = []
            for arrete in iti:
                iti_propre.append(arrete[0])
            iti_propre.append(iti[-1][1])
            coordinates_propre.append(iti_propre)
        # Test
        #print("coordonnées formatées apres ", coordinates_propre)
        return coordinates_propre
    
    def plot_itineraries_when_multiple(self,coo): # FINAL, NOT USED
        """
        Fonction qui permet de représenter les itinéraires optimaux sur une zone, avant que ceux-ci ne
        soient rattachés entre eux. Elle ne retourne rien puisqu'il s'agit d'une fonction de visualisation.

        Parameters
        ----------
        coo : List
            Liste de listes : chaque sous-liste est un itinéraire construit par les fonctions précédentes.

        Returns
        -------

        """
        for index, polyligne in enumerate(coo): # On parcourt chaque itinéraire optimal créé, on en fait une couche, et on la représente sur QGIS. 
            layer = QgsVectorLayer('LineString?crs=epsg:4326', f'Itineraire_{index}', 'memory')
            points = [QgsPointXY(*coord) for coord in polyligne]
            line = QgsGeometry.fromPolylineXY(points)
            feature = QgsFeature()
            feature.setGeometry(line)
            layer.dataProvider().addFeature(feature)
            QgsProject.instance().addMapLayer(layer)
        
    def plot_arrow_polyline(self, polyligne, instructions): # FINAL
        """
        Fonction qui permet de configruer la visualisation et représenter l'itinéraire final. Elle ne
        return rien, il ne s'agit que de visualisation.

        Parameters
        ----------
        polyligne : List
            Liste de tuples : c'est l'itinéraire final ordonné

        Returns
        -------

        """
        try :
            #print("polyligne a représenter : ", polyligne)
            points = [QgsPointXY(x[0], x[1]) for x in polyligne]
            
            # Création de la polyligne à partir des points
            polyline = QgsGeometry.fromPolylineXY(points)
            
            # Création d'une couche vectorielle pour stocker les segments de la polyligne
            layer = QgsVectorLayer("LineString?crs=EPSG:4326", "Itinéraire", "memory")
            provider = layer.dataProvider()
            
            # Définir les champs de la couche
            provider.addAttributes([QgsField("rang", QVariant.Int)])
            provider.addAttributes([QgsField("instruction", QVariant.String)])
            
            # Ajouter les entités et les attributs
            features = []
            for i in range(len(points) - 1):
                segment_start = points[i]
                segment_end = points[i + 1]
                
                # Création d'une entité pour le segment avec le rang attribué
                segment_feature = QgsFeature()
                segment_geometry = QgsGeometry.fromPolylineXY([segment_start, segment_end])
                segment_feature.setGeometry(segment_geometry)
                if len(instructions) >0:    
                    segment_feature.setAttributes([i + 1, instructions[i]])  # Attribution du rang (index + 1)
                else:
                    segment_feature.setAttributes([i + 1])
                features.append(segment_feature)

            # Ajout des entités à la couche
            provider.addFeatures(features)
            
            layer.updateFields()
            layer.updateExtents()
            
            # Définition du style de symbologie pour les flèches
            symbol_layer = QgsArrowSymbolLayer()
            #symbol_layer.setFillColor(QColor(255, 0, 0))  # Couleur de remplissage de la flèche
            
            line_symbol = QgsLineSymbol()
            line_symbol.setWidth(0.6)  # Épaisseur du contour de la flèche
            line_symbol.changeSymbolLayer(0, symbol_layer)
            
            # Définition du rendu de symboles unique
            renderer = QgsSingleSymbolRenderer(line_symbol)
            layer.setRenderer(renderer)
            
            # Ajout de la couche à la carte
            QgsProject.instance().addMapLayer(layer)
            
            # Sauvegarde de la couche dans un fichier
            layer_path = "C:/Users/Myriam/Documents/PLUGIN_QGIS_CORRECT/donnees_crees/la_couche_sortie.shp"  # Remplacez par le chemin de votre choix
            options = QgsVectorFileWriter.SaveVectorOptions()
            options.driverName = "ESRI Shapefile"
            QgsVectorFileWriter.writeAsVectorFormatV2(layer, layer_path, QgsCoordinateTransformContext(), options)
            
        except:
            points = []
            for i in range(0,len(polyligne) -1, 2):
                formate_point = (polyligne[i], polyligne[i+1])
                points.append(formate_point)
            self.plot_arrow_polyline(points, instructions)

    def draw_graph(self,G): # FINAL, NOT USED
        """
        Fonction qui permet de représenter le graphe construit pour représenter le réseau routier.

        Parameters
        ----------
        G : networkx.graph()
            Graphe représentant le réseau routier, avec les bonnes informations récupérées.

        Returns
        -------
        canvas.show() : canvas.show()
            Visualisation du graphe sur un autre onglet dans QGIS. 
        """
        
        # Créer une nouvelle couche vectorielle pour les nœuds du graphe
        layer_nodes = QgsVectorLayer("Point?crs=EPSG:4326", "Nodes", "memory")
        layer_nodes.startEditing()
        layer_nodes.addAttribute(QgsField("node_id", QVariant.Int))

        # Ajouter les nœuds au layer_nodes
        for i, node in enumerate(G.nodes()):
            feature = QgsFeature()
            point = QgsPointXY(*node)
            feature.setGeometry(QgsGeometry.fromPointXY(point))
            feature.setAttributes([i+1])  # Utilisation d'identifiants uniques pour les nœuds
            layer_nodes.addFeature(feature)

        layer_nodes.commitChanges()

        # Ajouter le layer_nodes à QgsProject
        QgsProject.instance().addMapLayer(layer_nodes)

        # Créer une nouvelle couche vectorielle pour les arêtes du graphe
        layer_edges = QgsVectorLayer("LineString?crs=EPSG:4326", "Edges", "memory")
        layer_edges.startEditing()
        layer_edges.addAttribute(QgsField("edge_id", QVariant.Int))

        # Ajouter les arêtes au layer_edges
        for i, edge in enumerate(G.edges()):
            start_node, end_node = edge
            start_point = QgsPointXY(*start_node)
            end_point = QgsPointXY(*end_node)
            feature = QgsFeature()
            feature.setGeometry(QgsGeometry.fromPolylineXY([start_point, end_point]))
            feature.setAttributes([i+1])  # Utilisation d'identifiants uniques pour les arêtes
            layer_edges.addFeature(feature)

        layer_edges.commitChanges()

        # Ajouter le layer_edges à QgsProject
        QgsProject.instance().addMapLayer(layer_edges)

        # Créer un canvas pour afficher la carte
        canvas = QgsMapCanvas()
        canvas.setDestinationCrs(layer_nodes.crs())
        canvas.setLayers([layer_nodes, layer_edges])
        canvas.zoomToFullExtent()

        # Afficher la carte dans la fenêtre de QGIS
        return canvas.show()
    
    def iti_petit_grand_tri(self,liste_de_liste): # FINAL
        """
        Fonction qui permet de trier les itinéraires : les plus petits et les plus grands

        Parameters
        ----------
        liste_de_liste : List
            Liste de listes : chaque sous-liste est un itinéraire construit par les fonctions préalables.

        Returns
        -------
        petits_iti : List
            Liste de liste avec chaque liste étant un petit itinéraire.
        grands_iti : List
            Liste de liste avec chaque liste étant un grand itinéraire.

        """
        # Test
        #print("iti petit grand tri début ", liste_de_liste)
        first_iti = liste_de_liste[0]
        petits_iti = []
        grands_iti = []
        for i in range(1, len(liste_de_liste)):
            if len(liste_de_liste[i]) <20:
                petits_iti.append(liste_de_liste[i])
            else :
                grands_iti.append(liste_de_liste[i])
        
        # On vérifie qu'on est pas dans le cas d'un petit réseau, où un seul itinéraire est suffisant et qui ne nécessite pas ce tri
        if len(petits_iti) == 0 and len(grands_iti) == 0 :
            return first_iti, 0, 0
        
        return first_iti, petits_iti, grands_iti
    
    def iti_mignon_oust(self,graph, petit_iti, grand_iti): # FINAL
        """
        Fonction qui sélectionne les petits itinéraires à proximité des grands itinéraires et les
        introduit dans les plus grands. Cela se modélise comme suit : grand_itinéraire(part 1) + petit
        itinéraire (entier) + Dijkstra entre le petit et le grand itinéraire + grand itinéraire (part 2)

        Parameters
        ----------
        graph : networkx.graph()
            Graphe netxorkx qui modélise le réseau routier : chaque arête est une route, chaque noeud une extrémité de route ou une intersection 
        petit_iti : list
            Liste de liste qui contient tous les petits itinéraire de la zone étudiée
        grand_iti : list
            Liste de liste qui contient tous les grands itinéraire de la zone étudiée 

        Returns
        -------
        petit_iti : list
            Liste de listes des petits itinéraires restants (ne correspondant pas aux critères de proximité)
        grand_iti : list
            Liste de listes des grands itinéraires, dont certains ont été modifiés

        """
        # Cas du petit réseau routier
        
        if petit_iti == 0 and grand_iti == 0:
            return 0,0
        
        # Cas général
        
        for petite_liste in petit_iti:
            noeud_depart = petite_liste[0] # On récupère le noeud de départ du petit itinéraire. 
            for grande_liste in grand_iti:
                if noeud_depart in grande_liste: # On vérifie la présence de ce noeud dans l'un des grands itinéraires.
                    noeud_fin = petite_liste[-1] # On récupère le noeud de fin du petit itinéraire.
                    retour_grand_iti = nx.dijkstra_path(graph, noeud_fin, noeud_depart) # On créé le chemin le plus court pour revenir de la fin de l'itinéraire à son début. 
                    for i in range(1, len(retour_grand_iti)):
                        tuple2 = retour_grand_iti[i]
                        petite_liste.append(tuple2) # On créé le petit itinéraire avec un retour à son point de départ.
                    idx_gd_liste = grand_iti.index(grande_liste) # On récupère l'index du grand itinéraire contenant une jonction avec le petit itinéraire.
                    grande_liste_en_question = grand_iti[idx_gd_liste]
                    for i in range(1,len(petite_liste)):
                        grande_liste_en_question.insert(grande_liste_en_question.index(noeud_depart)+i,petite_liste[i]) # On insert à la jonction la boucle de petit itinéraire créée précédement.
                    petit_iti.remove(petite_liste) # On retire des petits itinéraires l'itinéraire rattaché. 
                    break
        return petit_iti, grand_iti
    
    def multiples_to_one(self, graph, liste_coordinates, snake, iti_2): # FINAL
        """
        Fonction qui permet de créer l'itinéraire final (en terme de points passés) en collant chaque itinéraire
        bout-à-bout en fonction de leur proximité. Elle passe pour cela par une évaluation de la qualité des Dijkstra, d'un point
        d'arrivée d'itinéraire à un point de départ d'un autre. Il s'agit d'une fonction récursive pour permettre
        cette évaluation de toutes les options. 

        Parameters
        ----------
        graph : networkx.graph
            Graphe modélisant le réseau routier de la ville. 
        liste_coordinates : list
            Liste de liste, avec chaque liste un itinéraire optimal.
        snake : list
            Liste de listes qui ordonne les itinéraires de liste_coordinate pour optimiser le parcours total
        iti_2 : list
            Itinéraire à partir duquel on recherche un autre itinéraire, le plus proche.

        Returns
        -------
        snake : list
            Liste de listes avec les itinéraires ordonnés.

        """
        iti = iti_2
        last_point = iti[-1] # On récupère le dernier point de l'itinéraire en question 
        resultat_dijkstra = []
        for i in range(len(liste_coordinates)): # On parcourt les autres itinéraires
            if liste_coordinates[i] != iti : # Si l'itinéraire est différent de celui sur lequel on travaille, 
                premier_point = liste_coordinates[i][1] # On récupère son point de départ
                chemin_rattache = nx.dijkstra_path(graph, last_point, premier_point) # On créé un Dijkstra pour trouver le chemin le plus court entre ces points,
                resultat_dijkstra.append([chemin_rattache, liste_coordinates[i], i]) # On ajoute ce chemin, l'itinéraire en question, son index dans la liste_coordinates dans une liste.
        lengthT = []
        for i in range(len(resultat_dijkstra)): # On parcourt la liste créée
            groupe_d_interet = resultat_dijkstra[i]
            indexx = groupe_d_interet[2] 
            lengh = len(groupe_d_interet[0])
            lengthT.append([lengh, indexx])# On introduit la longueur de chaque Dijkstra.
        
        if len(lengthT) ==0: # Critère d'arrêt, il n'y a plus de voisins ! 
            snake.append(iti)
            return snake
        
        sous_liste_min = min(lengthT, key=lambda x: x[0]) # On récupère le Dijkstra avec le plus petit coût
        idx_plus_petit = sous_liste_min[1]

        for i, item in enumerate(resultat_dijkstra):
            if item[2] == idx_plus_petit:
                index_i = i
                break
        solve = resultat_dijkstra[index_i]
        snake.append([iti, solve[0][1:]]) # On ajoute à snake l'itinéraire parcouru, le dijkstra qui à l'itinéraire le plus proche...
        possibilite = solve[1] # Et on définit notre itinéraire d'intérêt pour la prochaine itération
        liste_coordinates.remove(iti) # On retire l'itinéraire parcouru de la liste_coordinates pour éviter de tourner en boucle. 
        
        return self.multiples_to_one(graph, liste_coordinates, snake, possibilite) # On réappelle la fonction jusqu'au critère d'arrêt. 
            
    def extraction_tuple(self,liste_a_trier): # FINAL
        """
        Fonction qui permet de transformer une liste d'itinéraire non formatée en une liste de tuples.
        Elle considère le cas ou deux voire trois sous-listes peuvent avoir été créées au maximum.

        Parameters
        ----------
        liste_a_trier : List
            Liste de listes, de listes de listes, de tuples : elle est mal formatée mais les informations sont chronologiquement correctes. 

        Returns
        -------
        u : List
            Liste de tuples qui consiste en la polyligne final, l'itinéraire ressorti pour la zone étudiée.
        """
        u = []
        for element in liste_a_trier:
            if type(element) == tuple:
                u.append(element)
            else:
                #Sinon, on sait déjà qu'il s'agit d'une liste
                for element2 in element:
                    if type(element2) == tuple:
                        u.append(element2)
                    else:
                        #On sait déja que c'est une liste
                        for element3 in element2:
                            if type(element3)== tuple:
                                u.append(element3)
                            else:
                                for element4 in element3:
                                    if type(element4) == tuple:
                                        u.append(element4)

        # Test
        #print("extraction tuples : ", u)
        return u
    
    def reformatage(self,rattache): # FINAL
        """
        Fonction qui condense la liste de deux listes (grands iti et petits iti) en une seule pour la préparer
        à la fonction créant l'itinéraire final.

        Parameters
        ----------
        rattache : List
            Liste de deux listes, avec dans chacune les itinéraires (soit les petis, soit les grands). 

        Returns
        -------
        coordinates_final : List
            Liste de tuples qui consiste en la polyligne finale, l'itinéraire ressorti pour le secteur de dénombrement étudié.
        """

        if rattache[0] == 0 and rattache[1]==0:
            return 0
            
        coordinates_final = [] # On ajoute les éléments de chaque liste dans une liste
        for iti in rattache[0]:
            coordinates_final.append(iti)
        for itou in rattache[1]:
            coordinates_final.append(itou)
            
        #Test propreté des itinéraires
        for i in coordinates_final:
            for j in i:
                if type(j) == list:
                    print("Error : your coordinates aren't good")
                    
        return coordinates_final
    
    def retoffement(self, troncons, itineraire_nodes): # NOT FINAL, NOT USED
        """
        Ebauche de fonction pour recoller les itinéraires sur les routes réelles.
        
        Parameters
        ----------
        troncons : Features
            Routes (avec la bonne géométrie)
        itineraire_nodes : List
            Liste des noeuds de l'itinéraire final

        Returns
        -------
        nouvel_itineraire : List
            Liste des tronçons dans leur enchaînement calculé par les fonctions de parcours optimal.
        """
        
        nouvel_itineraire = []
        for i in range(len(itineraire_nodes)-1):
            noeud_depart = itineraire_nodes[i]
            noeud_arrivee = itineraire_nodes[i+1]
            features = troncons.getFeatures()

            for troncon in features:
                geometry = troncon.geometry()
                polyline = geometry.asMultiPolyline()
                start_point = (polyline[0][0][0],polyline[0][0][1])
                end_point = (polyline[-1][-1][0],polyline[-1][-1][1])
                formatted_coord1 = (round(start_point[0], 7), round(start_point[1], 7))
                formatted_coord2 = (round(end_point[0], 7), round(end_point[1], 7))
                # Test
                #if formatted_coord1 == noeud_depart and formatted_coord2 == noeud_arrivee:
                    #print("le cas arrive !!")
                #elif formatted_coord1 == noeud_depart:
                    #print("super on a trouvé juste un point")    
            break
        return nouvel_itineraire
    
    def indications(self,every_coord): # FINAL
        """
        Fonction qui permet de générer des indication pour passer d'une route à la suivante dans l'itinéraire.
        Elle se base sur des calculs d'azimut.

        Parameters
        ----------
        every_coord : List
            Liste de tuples : Chaque tuple est un point de la polyligne.

        Returns
        -------
        guidage : List
            Liste des indications associées à chaque route pour passer à la suivante.
        """
        
        guidage = []
        if len(every_coord) < 1:
            return guidage
        else:
            for i in range (len(every_coord)-2):
                A = every_coord[i]
                B = every_coord[i+1]
                C = every_coord[i+2]

                lat_A = math.radians(A[1])
                longA = math.radians(A[0])
                
                lat_B = math.radians(B[1])
                longB = math.radians(B[0])
 
                lat_C = math.radians(C[1])
                longC = math.radians(C[0])
    
                Delta_long_AB = longB - longA
                Delta_long_BC = longC - longB
    
                azimut_AB = math.atan2(math.sin(Delta_long_AB) * math.cos(lat_B), math.cos(lat_A) * math.sin(lat_B) - math.sin(lat_A) * math.cos(lat_B) * math.cos(Delta_long_AB))
                azimut_BC = math.atan2(math.sin(Delta_long_BC) * math.cos(lat_C), math.cos(lat_B) * math.sin(lat_C) - math.sin(lat_B) * math.cos(lat_C) * math.cos(Delta_long_BC))
    
                diff_azimut = azimut_BC - azimut_AB
    
                if diff_azimut < 0:
                    diff_azimut += 2 * math.pi
                
                azimut_AB_degrees = math.degrees(azimut_AB)
                azimut_BC_degrees = math.degrees(azimut_BC)
                diff_azimut_degrees = math.degrees(diff_azimut)

                
                if 0 <= diff_azimut_degrees < 15 or 345 <= diff_azimut_degrees <= 360:
                    
                    indication =  " allez tout droit"
                elif 15 <= diff_azimut_degrees < 55 :
                    
                    indication = " serrez à droite"
                elif 55 <= diff_azimut_degrees < 125 :
                    
                    indication = " tournez à droite"
                elif 125 <= diff_azimut_degrees < 165:
                    
                    indication = " tournez franchement à droite"
                elif 165 <= diff_azimut_degrees < 195:
                    
                    indication = " faites demi tour"
                elif 195 <= diff_azimut_degrees < 235:
                    
                    indication = " tournez franchement à gauche"
                elif 235 <= diff_azimut_degrees < 305:
                    
                    indication = " tournez à gauche"
                else:
                    
                    indication = " serrez à gauche"
                
                guidage.append(indication)
                
            # Cas de la dernière route
            guidage.append("Vous avez terminé !")
            
        return guidage
    
    def get_first_node(self, adresse_a_geocoder): # FINAL
        """
        Fonction qui récupère la liste des coordonnées de départ, qui les transforme en chaine de caractère,
        puis qui analyse cette chaîne pour en ressortir une Liste de Tuples.

        Parameters
        ----------
        adresse_a_geocoder : Input
            Liste de coordonnées entrée par l'utilisateur, dont le type est non explicite. 

        Returns
        -------
        coordinates_list : List
            Liste de tuples qui consiste en les coordonnées rentrées par l'utilisateur, avec type explicite.
        """
        coordonnees = str(adresse_a_geocoder)
        try:
            # Utilisation de la fonction ast.literal_eval pour évaluer la chaîne en une structure de données Python
            coordinates_list = ast.literal_eval(coordonnees)
        
            # Vérification que chaque élément de la liste est un tuple de coordonnées
            if all(isinstance(coord, tuple) and len(coord) == 2 for coord in coordinates_list):
                return coordinates_list
            else:
                raise ValueError("La chaîne ne contient pas que des tuples de coordonnées valides.")
        except (ValueError, SyntaxError) as e:
            raise ValueError("La chaîne n'est pas au bon format.") from e      
    
    def add_start_line(self, firstline, reste): # FINAL
        """
        Fonction qui récupère l'itinéraire créé et qui ajoute à son début le premier itinéraire construit.

        Parameters
        ----------
        firstline : List
            Liste de tuples : premier itinéraire à partir du point de départ de l'utilisateur.
        reste : List
            Liste de tuples : reste de l'itinéraire sur le secteur de dénombrement. 

        Returns
        -------
        liste : List
            Liste de tuples : itinéraire global.
        """
        liste = []
        liste.append(firstline)
        for element in reste:
            liste.append(element)
        # Test
        #print("mon itinéraire apres rattache total : ", liste)
        return liste 
