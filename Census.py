# -*- coding: utf-8 -*-
"""
/***************************************************************************
 Census
                                 A QGIS plugin
 Ce plugin permet de définir un parcours optimal sur une zone définie par l'utilisateur dasn un contexte de recensement dans des zones où les données sont moindres
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2023-06-16
        git sha              : $Format:%H$
        copyright            : (C) 2023 by Victorien OLLIVIER
        email                : victorien.ollivier@ensg.eu
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
from qgis.PyQt.QtCore import QSettings, QTranslator, QCoreApplication
from qgis.PyQt.QtGui import QIcon,QColor
from qgis.PyQt.QtWidgets import QAction, QFileDialog, QTextEdit, QDialog, QVBoxLayout, QDialogButtonBox, QLineEdit, QLabel, QMessageBox

# Initialize Qt resources from file resources.py
from .resources import *
# Import the code for the dialog
from .Census_dialog import CensusDialog
import os.path
from qgis.core import *
import processing
import networkx as nx
from networkx.algorithms import approximation
import random
from PyQt5.QtCore import QVariant
#import qgis.core.QgsPalLayerSettings
#from qgis.core import QgsPalLayerSettings
#from qgis.core import QgsLabeling, QgsLabelAttribute, QgsExpression, QgsLinePlacement, QgsMarkerSymbol, QgsSingleSymbolRenderer
#from qgis.gui import QgsCurveArrowSymbolLayer
#from qgis.core import QgsVectorLayer, QgsProject,QgsFeature, QgsExpression, QgsFeatureRequest, QgsVectorLayerUtils

class Census:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        self.iface = iface
        self.plugin_dir = os.path.dirname(__file__)
        self.menu = self.tr(u'&Census')
        self.first_start = None
        self.actions = []

    def tr(self, message):
        return QCoreApplication.translate('Census', message)

    def add_action(self, icon_path, text, callback):
        icon = QIcon(icon_path)
        action = QAction(icon, text, self.iface.mainWindow())
        action.triggered.connect(callback)
        self.iface.addToolBarIcon(action)
        self.actions.append(action)
        return action

    def initGui(self):
        icon_path = ':/plugins/Census/icon.png'
        self.add_action(icon_path, text=self.tr(u'Census'), callback=self.run)
        self.first_start = True

    def unload(self):
        for action in self.actions:
            self.iface.removeToolBarIcon(action)

    def select_output_file(self, line_edit):
        dialog = QFileDialog()
        dialog.setFileMode(QFileDialog.ExistingFile)
        dialog.setNameFilter("Shapefile (*.shp)")
        if dialog.exec_():
            filenames = dialog.selectedFiles()
            if filenames:
                filename = filenames[0]
                line_edit.setText(filename)

    def run(self):
        if self.first_start:
            self.first_start = False
            self.dlg = CensusDialog()

            self.dlg.pushShpRoads.clicked.connect(lambda: self.select_output_file(self.dlg.lineShpRoads))
            self.dlg.pushShpHydro.clicked.connect(lambda: self.select_output_file(self.dlg.lineShpHydro))
            self.dlg.pushShpZone.clicked.connect(lambda: self.select_output_file(self.dlg.lineShpZone))

        # show the dialog
        self.dlg.show()
        # Run the dialog event loop
        result = self.dlg.exec_()
        # See if OK was pressed
        if result:
            shp_roads_path = self.dlg.lineShpRoads.text()
            shp_hydro_path = self.dlg.lineShpHydro.text()
            shp_zone_path = self.dlg.lineShpZone.text()
            
            # Check shapefile validity
            if not self.is_valid_shapefile(shp_roads_path):
                return
            if not self.is_valid_shapefile(shp_hydro_path):
                return
            if not self.is_valid_shapefile(shp_zone_path):
                return
            
            self.process_shapefiles(shp_roads_path, shp_hydro_path, shp_zone_path)

    def is_valid_shapefile(self, shp_path):
        layer = QgsVectorLayer(shp_path, "Validation Layer", "ogr")
        if not layer or not layer.isValid():
            QMessageBox.warning(
                self.iface.mainWindow(),
                "Validation Error",
                "The file \"%s\" is not a valid shapefile." % shp_path.replace(':', os.sep)
                )
            return False
        return True
    

    def process_shapefiles(self, shp_roads_path, shp_hydro_path, shp_zone_path):
        Z_layer, R_layer, H_layer = self.plot_couches_entrees(shp_roads_path, shp_hydro_path, shp_zone_path)
        #Z_layer, R_layer, H_layer = self.reduction_donnees_au_necessaire(shp_roads_path,shp_hydro_path,shp_zone_path)
        #T_layer = self.explosion_des_routes(R_layer)
        T_layer = R_layer
        #QgsProject.instance().addMapLayer(T_layer)
        arretes = self.creation_arrete(T_layer)
        G_zone = self.creation_graphe(arretes)
      #  grouph = self.draw_graph(G_zone)
        itineraire, solution = self.meilleur_glouton(G_zone, 1000)
        
        clean_parcours_zone = self.coordonnees_formatees(itineraire)
        
        first_tri = self.iti_petit_grand_tri(clean_parcours_zone)
        apres_premier_tarrachement = self.iti_mignon_oust(G_zone, first_tri[0], first_tri[1])
        remise_en_forme = self.reformatage(apres_premier_tarrachement)
        tryingsmth = self.plot_itineraries_when_multiple(remise_en_forme)
        #last_iti = self.unique(G_zone,remise_en_forme)
        snake = []
        last_iti = self.multiples_to_one(G_zone, remise_en_forme, snake, remise_en_forme[0])
        couche_finish = self.extraction_tuple(last_iti)
        
        #couche_sur_troncon = self.re_etoffement( arretes, couche_finish)
        #couche_sur_troncon = self.re_etoffement_tes(T_layer, couche_finish)
        # #print("couchefinale bien formatée sa mère", couche_finish)
        couche_iti = self.plot_arrow_polyline(couche_finish)
        return couche_iti
     
    def plot_couches_entrees(self,shp_roads_path, shp_hydro_path, shp_zone_path):
        # FONCTIONNE
        zone_layer = QgsVectorLayer(shp_zone_path, "Zone", "ogr")
        roads_layer = QgsVectorLayer(shp_roads_path, "Routes", "ogr")
        hydro_layer = QgsVectorLayer(shp_hydro_path, "Hydrographie", "ogr")
        QgsProject.instance().addMapLayer(zone_layer)
        QgsProject.instance().addMapLayer(roads_layer)
        QgsProject.instance().addMapLayer(hydro_layer)
        return zone_layer, roads_layer, hydro_layer

    def reduction_donnees_au_necessaire(self, shp_roads_path, shp_hydro_path, shp_zone_path):
        zone_layer = QgsVectorLayer(shp_zone_path, "Zone", "ogr")
        roads_layer = QgsVectorLayer(shp_roads_path, "Routes", "ogr")
        hydro_layer = QgsVectorLayer(shp_hydro_path, "Hydrographie", "ogr")
        
        if not roads_layer.isValid() or not zone_layer.isValid():
            print("Erreur lors du chargement des couches.")
        else:
            # Effectuer la sélection par expression
            expression = f'intersects($geometry, geometry(get_feature(\'{zone_layer.name()}\', 1)))'
            roads_layer.selectByExpression(expression, QgsVectorLayer.SetSelection)
            
            # Créer une nouvelle couche avec les entités sélectionnées
            layer_resultat = QgsVectorLayer("LineString?crs=epsg:4326", "Résultat", "memory")
            layer_resultat.dataProvider().addFeatures([f for f in roads_layer.selectedFeatures()])
        
        # Ajouter la couche résultat à la carte
            QgsProject.instance().addMapLayer(layer_resultat)
        
        QgsProject.instance().addMapLayer(zone_layer)
        QgsProject.instance().addMapLayer(hydro_layer)
        
        return zone_layer, layer_resultat, hydro_layer



    def explosion_des_routes(self, road_layer): # Cette fonction est opérationnelle et est commentée.
        """
        Fonction qui permet de passer des entités "routes" aux tronçons qui les composent,
        et donc de prendre en compte la totalité des noeuds nécessaires à la modélisation
        du réseau en graphe, prenant en compte les interesections de routes non
        explicites dans les données "routes"

        Parameters
        ----------
        road_layer : QgsVectorLayer
            Couche QGIS qui stocke toutes les données routières 

        Returns
        -------
        features_troncons : QgsVectorLayer
            Couche QGIS qui stocke tous les tronçons de chaque route.

        """
        
        # Spécifie le chemin vers le fichier de sortie pour les lignes explosées, à demander à l'utilisateur.
        output_layer = 'C:/Users/Myriam/Documents/IT2/stage/la_couche_sortie.shp'

        # Utilisation du processing pour exploser les lignes
        parameters = {'INPUT': road_layer, 'OUTPUT': output_layer, 'OVERWRITE': True}
        processing.run('qgis:explodelines', parameters)

        # Création et représentation de la couche des routes explosées sur QGIS
        explode_layer = QgsVectorLayer(output_layer, "Troncons", "ogr")
        QgsProject.instance().addMapLayer(explode_layer)
        # if not explode_layer.isValid():
        #     print("Layer failed to load!")
        # else:
        #     QgsProject.instance().addMapLayer(explode_layer)
        
        # Récupération des features de la couche, sortie
        
        features_troncons = explode_layer.getFeatures()
        
        return features_troncons
    
    def creation_arrete(self, troncons): # Cette fonction est opérationnelle et est commentée.
        """
        Fonction qui prend en entrée les tronçons du réseau routier et qui ramène
        les arretes nécessaires, afin que chaque arrete représente une portion de route,
        mais que l'on puisse prendre en compte les intersections dans le graphe.

        Parameters
        ----------
        troncons : features
            Features de la couche QGIS qui stocke toutes les troncons 

        Returns
        -------
        arretes : list
            Liste de deux tuples, paire de noeud.

        """
        troncons_layer = troncons.getFeatures()
        
        arretes = []
        id1 = 0
        
        # Boucle de tri pour conserveruniquement les noeuds de départ, d'arrivée et d'intersection des routes. 
        for feature in troncons_layer:
            geometry = feature.geometry()
            multi_line = geometry.asMultiPolyline()
            id1 = feature.attribute("osm_id")
            id2 = 0
            for line in multi_line:
                start_point = [line[0][0], line[0][1], feature.id()]
                end_point = [line[-1][0], line[-1][1], feature.id()]
                id2 = id2 + 1
                formatted_line = [start_point, end_point,id1,id2]
                # On stocke nos arretes dans une liste
                arretes.append(formatted_line)
        
        return arretes
    
    def creation_graphe(self, arretes_de_zone): # Cette fonction est opérationnelle et est commentée.
        """
        Fonction qui prend en entrée les arretes qui représentent le réseau routier au mieux, et
        qui ressort un graph, une modélisation avec noeuds (nodes) et arretes (edges)

        Parameters
        ----------
        arretes_de_zone : liste
            Liste de liste de tuples, qui sont les arretes (paires de noeuds)

        Returns
        -------
        G : networkx.graph
            Le graphe qui modélise le réseau routier.

        """
        
        
        # Initialisation d'un graphe
        G = nx.Graph()

        # Construction du graphe et remplissage
        for start_point, end_point, id1, id2 in arretes_de_zone:
            start_node = tuple(start_point[:2])
            end_node = tuple(end_point[:2])
            edge_label = f"{id1}_{id2}"  # Étiquette de l'arête
            
        # Ajout des nœuds et l'arête au graphe
            G.add_node(start_node)
            G.add_node(end_node)
            G.add_edge(start_node, end_node, label=edge_label, weight=1)

        # Identification des nœuds inutiles
        modified = True
        
        while modified:
            modified = False
            
            for node in list(G.nodes()):
                neighbors = list(G.neighbors(node))
                
                if len(neighbors) == 2:
                    arretes_voisines = []
                    for voisin in neighbors:
                        edge_label = G.edges[node, voisin]['label']
                        arretes_voisines.append(edge_label)
                    label1 = arretes_voisines[0]
                    label2 = arretes_voisines[1]
                    
                    if label1 == label2:
                        
                        # On retire les noeuds inutiles et on reconstruit l'arrete.
                        G.remove_node(node)
                        G.add_edge(neighbors[0], neighbors[1], label=label1, weight=2) #attention, le poids devra etre une pondération
                        modified = True
                        break

        return G

    def chemin_optimal(self, graph,passed_edges,passed_nodes, nombre_true,poids_total_parcouru, noeud_depart):
        
        #FONCTIONNE
        
        nombre_edges = graph.number_of_edges()
       # print("nombre true", nombre_true)
        if nombre_true >= nombre_edges:
            return passed_edges, poids_total_parcouru
        liste_noeuds_libres = []
        for node in list(graph.nodes()):
            neighbors = list(graph.neighbors(node))
            for voisin in neighbors:    
                if graph.edges[node, voisin]['Visited'] == False:
                    liste_noeuds_libres.append(node)
                    break
        if noeud_depart == 0:
            if len(liste_noeuds_libres) > 0:
                start_node = liste_noeuds_libres[0]
                passed_nodes.append(start_node)
            else:
                print("c'est la merde")
        else:
            start_node = noeud_depart
            
            
        graph.nodes[start_node]['Visited'] = True
        

        passed_nodes.append(start_node)
        
        # Tant que on a pas tout parcouru une fois, on continue
        while nombre_true < nombre_edges:

            noeud_ou_nous_sommes = passed_nodes[-1]
            
            voisins_du_noeud_ou_nous_sommes = list(graph.neighbors(noeud_ou_nous_sommes))
            
            if len(voisins_du_noeud_ou_nous_sommes) == 1:
                #DEGREE 1
                # Dans ce cas de figure, on est en bout d'arrete et il n'y a pas de voisins, il faut faire demi-tour
                
                noeud_suivant = voisins_du_noeud_ou_nous_sommes[0]
                
                graph.nodes[noeud_suivant]['Visited'] = True
                if graph.edges[noeud_ou_nous_sommes,noeud_suivant]['Visited'] ==False:
                    nombre_true +=1
                    graph.edges[noeud_ou_nous_sommes,noeud_suivant]['Visited'] =True
                else:
                    graph.edges[noeud_ou_nous_sommes,noeud_suivant]['Visited'] =True
                poids_total_parcouru += graph.edges[noeud_ou_nous_sommes,noeud_suivant]['weight']
                passed_nodes.append(noeud_suivant)
                passed_edges.append((noeud_ou_nous_sommes, noeud_suivant))
            
            else:
                arretes_pas_visites=[]
            
                for noeud in voisins_du_noeud_ou_nous_sommes:
                    arrete = graph.edges[(noeud_ou_nous_sommes,noeud)]
                    if arrete['Visited'] == False:
                        arretes_pas_visites.append([arrete, noeud_ou_nous_sommes, noeud])
                
                if len(arretes_pas_visites)>=2 :
                    #DEGREE 1
                    poids = []
                    for arrete in arretes_pas_visites:
                        poids.append(arrete[0]['weight'])
                    idx_min_poids = poids.index(min(poids))
                    arrete_plus_petit_poids = arretes_pas_visites[idx_min_poids]
                    noeud1 = arrete_plus_petit_poids[1]
                    noeud2 = arrete_plus_petit_poids[2]
                    noeud_suivant = noeud2
                    graph.nodes[noeud_suivant]['Visited'] = True
                    graph.edges[noeud1, noeud_suivant]['Visited'] = True
                    nombre_true+=1
                    poids_total_parcouru += graph.edges[noeud1,noeud_suivant]['weight']
                        
                    passed_nodes.append(noeud_suivant)
                    passed_edges.append((noeud1, noeud_suivant))
                    
                elif len(arretes_pas_visites) == 1 :
                    arrete = arretes_pas_visites[0]
                    
                    noeud1 = arrete[1]
                    noeud2 = arrete[2]
                    
                    noeud_suivant = noeud2
                    graph.nodes[noeud_suivant]['Visited'] = True
                    graph.edges[noeud1, noeud_suivant]['Visited'] = True
                    
                    passed_nodes.append(noeud_suivant)
                    passed_edges.append((noeud1, noeud_suivant))
                    nombre_true+=1
                    poids_total_parcouru += graph.edges[noeud1,noeud_suivant]['weight']
                        
                
                else:
                    #On est dans la situation suivante : il y a plus d'un voisin. Ils sonttous visités
                    #print("cas pas facile en approche")
                    
                    liste_noeuds_voisins_libres = []
                    for noeud in voisins_du_noeud_ou_nous_sommes:
                        
                     #   print("ok, on rentre dans la boucle 158")
                      #  arrete_visitees = graph.edges[(noeud_ou_nous_sommes,noeud)]
                        les_voisins_du_voisin = list(graph.neighbors(noeud))
                      #  print("les voisins du voisin", les_voisins_du_voisin)
                        for voisinvoisin in les_voisins_du_voisin:
                       #     print("on cherche si les arretes sont false a degree 2")
                            if graph.edges[noeud, voisinvoisin]['Visited'] == False:
                                edge_cas_degree_deux = graph.edges[(noeud_ou_nous_sommes,noeud)]
                                liste_noeuds_voisins_libres.append([edge_cas_degree_deux,noeud_ou_nous_sommes, noeud])
                        #        print("la liste est elle remplie ?", liste_noeuds_voisins_libres)
                                
                    
                    if len(liste_noeuds_voisins_libres) > 0:
                        #print("bon alors ca arrive !")
                        arrete = liste_noeuds_voisins_libres[0]
                     #   print("arretes  l123 : ", arrete)
                        
                        noeud1 = arrete[1]
                        noeud2 = arrete[2]
                        
                        noeud_suivant = noeud2
                        graph.nodes[noeud_suivant]['Visited'] = True
                        graph.edges[noeud1, noeud_suivant]['Visited'] = True
                        
                        passed_nodes.append(noeud_suivant)
                        passed_edges.append((noeud1, noeud_suivant))
                        poids_total_parcouru += graph.edges[noeud1,noeud_suivant]['weight']
                    
                    else :
                        liste_noeuds_voisins_voisins_libres = []
                        for noeud in voisins_du_noeud_ou_nous_sommes:
                            les_voisins_du_voisin = list(graph.neighbors(noeud))
                            for cousin in les_voisins_du_voisin:
                                cousincousin = list(graph.neighbors(cousin))
                                for indiv in cousincousin:
                                    if graph.edges[cousin, indiv]['Visited'] == False:
                                        edges_cas_degree_trois = graph.edges[(noeud_ou_nous_sommes, noeud)]
                                        liste_noeuds_voisins_voisins_libres.append([edges_cas_degree_trois,noeud_ou_nous_sommes,noeud])
                        
                        
                        if len(liste_noeuds_voisins_voisins_libres) > 0:
                            arrete = liste_noeuds_voisins_voisins_libres[0]
                            noeud1 = arrete[1]
                            noeud2 = arrete[2]
                            noeud_suivant = noeud2
                            graph.nodes[noeud_suivant]['Visited'] = True
                            graph.edges[noeud1, noeud_suivant]['Visited'] = True
                            passed_nodes.append(noeud_suivant)
                            passed_edges.append((noeud1, noeud_suivant))
                            poids_total_parcouru += graph.edges[noeud1,noeud_suivant]['weight']
                            
                        
                        else:
                            liste_noeuds_voisin_degre4 = []
                            for noeud in voisins_du_noeud_ou_nous_sommes:
                                les_voisins_du_voisins = list(graph.neighbors(noeud))
                                for cousin in les_voisins_du_voisins:
                                    cousincousin = list(graph.neighbors(cousin))
                                    for indiv in cousincousin:
                                        voisinsdeg4 = list(graph.neighbors(indiv))
                                        for individu in voisinsdeg4:
                                            if graph.edges[indiv,individu]['Visited'] ==False:
                                                edges_cas_degree_quatre = graph.edges[(noeud_ou_nous_sommes, noeud)]
                                                liste_noeuds_voisin_degre4.append([edges_cas_degree_quatre,noeud_ou_nous_sommes,noeud])
                            if len(liste_noeuds_voisin_degre4) > 0:
                                arrete = liste_noeuds_voisin_degre4[0]
                                noeud1 = arrete[1]
                                noeud2 = arrete[2]
                                noeud_suivant = noeud2
                                graph.nodes[noeud_suivant]['Visited'] = True
                                graph.edges[noeud1, noeud_suivant]['Visited'] = True
                                passed_nodes.append(noeud_suivant)
                                passed_edges.append((noeud1, noeud_suivant))
                                poids_total_parcouru += graph.edges[noeud1,noeud_suivant]['weight']
                                
                            else:
                                
                            #print("arretes_pas_visites l92 ", arretes_pas_visites)
                           # print("on trouve une autre portion de chemin")
                                return self.chemin_optimal(graph, passed_edges,passed_nodes, nombre_true,poids_total_parcouru, 0)
        return passed_edges, poids_total_parcouru
    
    def tri_itineraires(self,chemin):
        """
        Fonction qui permet de passer des entités "routes" aux tronçons qui les composent,
        et donc de prendre en compte la totalité des noeuds nécessaires à la modélisation
        du réseau en graphe, prenant en compte les interesections de routes non
        explicites dans les données "routes"

        Parameters
        ----------
        road_layer : QgsVectorLayer
            Couche QGIS qui stocke toutes les données routières 

        Returns
        -------
        features_troncons : QgsVectorLayer
            Couche QGIS qui stocke tous les tronçons de chaque route.

        """
        
        #FONCTIONNE
        
        les_chemins = []  # Liste pour stocker les itinéraires
        chemin_temporaire = []  # Liste temporaire pour un itinéraire courant

        for troncon in chemin:
            if len(chemin_temporaire) == 0:
                chemin_temporaire.append(troncon)
            else:
                dernier_troncon = chemin_temporaire[-1]
                noeud_fin_dernier = dernier_troncon[1]
                noeud_debut_actuel = troncon[0]

                if noeud_fin_dernier == noeud_debut_actuel:
                    chemin_temporaire.append(troncon)
                else:
                    les_chemins.append(chemin_temporaire)
                    chemin_temporaire = [troncon]

        if len(chemin_temporaire) > 0:
            les_chemins.append(chemin_temporaire)

        return les_chemins
    
    def meilleur_glouton(self,G,nombre_de_relance):
        
        #FONCTIONNE
        
        liste_infos_pour_chaque_iti = []
        
        for i in range(nombre_de_relance):
            #print("premiertest")
            nx.set_node_attributes(G, False, 'Visited')
            nx.set_edge_attributes(G, False, 'Visited')
         
            poids_total_parcouru = 0
            noeud_depart = random.choice(list(G.nodes()))
            #print("le noeud de départ", noeud_depart)
            passed_edges = []
            passed_nodes = []
            nombre_true = 0
            A = self.chemin_optimal(G, passed_edges,passed_nodes,nombre_true,poids_total_parcouru, noeud_depart)
            #print("le chemin : ", A)
            B = self.tri_itineraires(A[0])
            #print("mon tri en plusieurs itinéraires : ", B)
            nombre_iti = len(B)
            #print("Il y a ", nombre_iti, " itinéraires différents construits")
            poids_de_la_relance = A[1]
            #print(poids_de_la_relance)
            #print("une itération est réalisée")
            
            #Definition de l'indice d'optimalité, qu'on souhaite minimiser. 
            alpha = 0.85
            beta = 0.15
            indice_optimalite = alpha * nombre_iti + beta * poids_de_la_relance
            #print("indice d'optimalité :", indice_optimalite)
            liste_infos_pour_chaque_iti.append([A, B, nombre_iti, poids_de_la_relance, indice_optimalite])
        
        R_min = []
        for iti_possible in liste_infos_pour_chaque_iti:
            R_min.append(iti_possible[-1])
        
        minimum = min(R_min)
        index_minimum = R_min.index(minimum)
       # print("le minimum est :", minimum,"d'index", index_minimum)
        solution = liste_infos_pour_chaque_iti[index_minimum]
        itineraire_final = solution[1]
        
        return itineraire_final, solution
    
    def coordonnees_formatees(self,solution):
        
        #FONCTIONNE
        
        coordinates_propre = []
        for iti in solution :
            iti_propre = []
            for arrete in iti:
                iti_propre.append(arrete[0])
            iti_propre.append(iti[-1][1])
            coordinates_propre.append(iti_propre)
     #   print("ce qui doit passer en entrée : ", coordinates_propre)
     #   print("sa longueur ", len(coordinates_propre))
        #for element in coordinates_propre:
        #    print("longueur de la sous liste : ", len(element))
        return coordinates_propre
    
    def plot_itineraries_when_multiple(self,coo):
        
        #FONCTIONNE
        
        for index, polyligne in enumerate(coo):
           # print("polyligne a représenter : ", len(polyligne))
            layer = QgsVectorLayer('LineString?crs=epsg:4326', f'Itineraire_{index}', 'memory')
            points = [QgsPointXY(*coord) for coord in polyligne]
            line = QgsGeometry.fromPolylineXY(points)
            feature = QgsFeature()
            feature.setGeometry(line)
            layer.dataProvider().addFeature(feature)
            QgsProject.instance().addMapLayer(layer)
    
    def plot_itineraries(self, coo):
       # print("polyligne a représenter : ", len(coo))
        layer = QgsVectorLayer('LineString?crs=epsg:4326', 'Itinéraire', 'memory')
        points = [QgsPointXY(coord[0], coord[1]) for coord in coo]
        line = QgsGeometry.fromPolylineXY(points)
        feature = QgsFeature()
        feature.setGeometry(line)
        layer.dataProvider().addFeature(feature)
        QgsProject.instance().addMapLayer(layer)
    
    
    def plot_arrow_polyline(self, polyligne):
        points = [QgsPointXY(x[0], x[1]) for x in polyligne]
        
        # Création de la polyligne à partir des points
        polyline = QgsGeometry.fromPolylineXY(points)
        
        # Création d'une couche vectorielle pour stocker les segments de la polyligne
        layer = QgsVectorLayer("LineString?crs=EPSG:4326", "Itinéraire", "memory")
        provider = layer.dataProvider()
        
        # Définir les champs de la couche
        provider.addAttributes([QgsField("rang", QVariant.Int)])
        
        # Ajouter les entités et les attributs
        features = []
        for i in range(len(points) - 1):
            segment_start = points[i]
            segment_end = points[i + 1]
            
            # Création d'une entité pour le segment avec le rang attribué
            segment_feature = QgsFeature()
            segment_geometry = QgsGeometry.fromPolylineXY([segment_start, segment_end])
            segment_feature.setGeometry(segment_geometry)
            segment_feature.setAttributes([i + 1])  # Attribution du rang (index + 1)
            
            features.append(segment_feature)
            
            # Ajout des entités à la couche
        provider.addFeatures(features)
        
        layer.updateFields()
        layer.updateExtents()
        
        # Définition du style de symbologie pour les flèches
        symbol_layer = QgsArrowSymbolLayer()
        #symbol_layer.setFillColor(QColor(255, 0, 0))  # Couleur de remplissage de la flèche
        
        line_symbol = QgsLineSymbol()
        line_symbol.setWidth(0.6)  # Épaisseur du contour de la flèche
        line_symbol.changeSymbolLayer(0, symbol_layer)
        
        # Définition du rendu de symboles unique
        renderer = QgsSingleSymbolRenderer(line_symbol)
        layer.setRenderer(renderer)
        
        # Ajout de la couche à la carte
        QgsProject.instance().addMapLayer(layer)
        
        #Ajout d'étiquettes
        #Probleme d'importations....
    

    def draw_graph(self,G):
        
        #FONCTIONNE, enfin pas vraiment, probleme avec la création du canva...
        
    # Créer une nouvelle couche vectorielle pour les nœuds du graphe
        layer_nodes = QgsVectorLayer("Point?crs=EPSG:4326", "Nodes", "memory")
        layer_nodes.startEditing()
        layer_nodes.addAttribute(QgsField("node_id", QVariant.Int))

    # Ajouter les nœuds au layer_nodes
        for i, node in enumerate(G.nodes()):
            feature = QgsFeature()
            point = QgsPointXY(*node)
            feature.setGeometry(QgsGeometry.fromPointXY(point))
            feature.setAttributes([i+1])  # Utilisation d'identifiants uniques pour les nœuds
            layer_nodes.addFeature(feature)

        layer_nodes.commitChanges()

    # Ajouter le layer_nodes à QgsProject
        QgsProject.instance().addMapLayer(layer_nodes)

    # Créer une nouvelle couche vectorielle pour les arêtes du graphe
        layer_edges = QgsVectorLayer("LineString?crs=EPSG:4326", "Edges", "memory")
        layer_edges.startEditing()
        layer_edges.addAttribute(QgsField("edge_id", QVariant.Int))

    # Ajouter les arêtes au layer_edges
        for i, edge in enumerate(G.edges()):
            start_node, end_node = edge
            start_point = QgsPointXY(*start_node)
            end_point = QgsPointXY(*end_node)
            feature = QgsFeature()
            feature.setGeometry(QgsGeometry.fromPolylineXY([start_point, end_point]))
            feature.setAttributes([i+1])  # Utilisation d'identifiants uniques pour les arêtes
            layer_edges.addFeature(feature)

        layer_edges.commitChanges()

    # Ajouter le layer_edges à QgsProject
        QgsProject.instance().addMapLayer(layer_edges)

    # Créer un canvas pour afficher la carte
        canvas = QgsMapCanvas()
        canvas.setDestinationCrs(layer_nodes.crs())
        canvas.setLayers([layer_nodes, layer_edges])
        canvas.zoomToFullExtent()

    # Afficher la carte dans la fenêtre de QGIS
        return canvas.show()
    
    
    
    
    def iti_petit_grand_tri(self,liste_de_liste): # Cette fonction est opérationnelle et est commentée.
        """
        Fonction qui permet de trier les itinéraires : les plus petits et les plus grands

        Parameters
        ----------
        liste_de_liste : List
            Liste de listes : chaque sous-liste est un itinéraire construit par les fonctions préalables.

        Returns
        -------
        petits_iti : List
            Liste de liste avec chaque liste étant un petit itinéraire.
        grands_iti : List
            Liste de liste avec chaque liste étant un grand itinéraire.

        """
        petits_iti = []
        grands_iti = []
        for liste in liste_de_liste:
            if len(liste) <20:
                petits_iti.append(liste)
                
            else:
                grands_iti.append(liste)
        
        return petits_iti, grands_iti
    
    def iti_mignon_oust(self,graph, petit_iti, grand_iti): # Cette fonction est opérationnelle et est commentée.
        """
        Fonction qui sélectionne les petits itinéraires à proximité des grands itinéraires et les
        introduit dans les plus grands. Cela se modélise comme suit : grand_itinéraire(part 1) + petit
        itinéraire (entier) + Dijkstra entre le petit et le grand itinéraire + grand itinéraire (part 2)

        Parameters
        ----------
        graph : networkx.graph()
            Graphe netxorkx qui modélise le réseau routier : chaque arête est une route, chaque noeud une extrémité de route ou une intersection 
        petit_iti : list
            Liste de liste qui contient tous les petits itinéraire de la zone étudiée
        grand_iti : list
            Liste de liste qui contient tous les grands itinéraire de la zone étudiée 

        Returns
        -------
        petit_iti : list
            Liste de listes des petits itinéraires restants (ne correspondant pas aux critères de proximité)
        grand_iti : list
            Liste de listes des grands itinéraires, dont certains ont été modifiés

        """
        
        for petite_liste in petit_iti:
            noeud_depart = petite_liste[0] # On récupère le noeud de départ du petit itinéraire. 
            for grande_liste in grand_iti:
                if noeud_depart in grande_liste: # On vérifie la présence de ce noeud dans l'un des grands itinéraires.
                    noeud_fin = petite_liste[-1] # On récupère le noeud de fin du petit itinéraire.
                    retour_grand_iti = nx.dijkstra_path(graph, noeud_fin, noeud_depart) # On créé le chemin le plus court pour revenir de la fin de l'itinéraire à son début. 
                    for i in range(1, len(retour_grand_iti)):
                        tuple2 = retour_grand_iti[i]
                        petite_liste.append(tuple2) # On créé le petit itinéraire avec un retour à son point de départ.
                    idx_gd_liste = grand_iti.index(grande_liste) # On récupère l'index du grand itinéraire contenant une jonction avec le petit itinéraire.
                    grande_liste_en_question = grand_iti[idx_gd_liste]
                    for i in range(1,len(petite_liste)):
                        grande_liste_en_question.insert(grande_liste_en_question.index(noeud_depart)+i,petite_liste[i]) # On insert à la jonction la boucle de petit itinéraire créée précédement.
                    petit_iti.remove(petite_liste) # On retire des petits itinéraires l'itinéraire rattaché. 
                    break
        return petit_iti, grand_iti
    
    def multiples_to_one(self, graph, liste_coordinates, snake, iti_2):
        iti = iti_2
        last_point = iti[-1]
        resultat_dijkstra = []
        for i in range(len(liste_coordinates)):
            if liste_coordinates[i] != iti :
                premier_point = liste_coordinates[i][1]
                chemin_rattache = nx.dijkstra_path(graph, last_point, premier_point)
                resultat_dijkstra.append([chemin_rattache, liste_coordinates[i], i])
        lengthT = []
        for i in range(len(resultat_dijkstra)):
            groupe_d_interet = resultat_dijkstra[i]
            indexx = groupe_d_interet[2]
            lengh = len(groupe_d_interet[0])
            lengthT.append([lengh, indexx])
        
        if len(lengthT) ==0:
            snake.append(iti)
            return snake
        sous_liste_min = min(lengthT, key=lambda x: x[0])
        idx_plus_petit = sous_liste_min[1]

        for i, item in enumerate(resultat_dijkstra):
            if item[2] == idx_plus_petit:
                index_i = i
                break
        solve = resultat_dijkstra[index_i]
        snake.append([iti, solve[0][1:]])
        possibilite = solve[1]
        liste_coordinates.remove(iti)
        
        return self.multiples_to_one(graph, liste_coordinates, snake, possibilite)
    

    
    def unique(self,graph, liste_coordinates):
        snake = []
        for i in range(len(liste_coordinates) - 1):
            itineraire_en_question = liste_coordinates[i]
            itineraire_suivant = liste_coordinates[i+1]
            start_node = itineraire_en_question[-1]
            end_node = itineraire_suivant[0]
            
            route_entre_les_deux = nx.dijkstra_path(graph, start_node, end_node)
            snake.append([itineraire_en_question, route_entre_les_deux[1:-1]])
        snake.append(liste_coordinates[-1])
        
        return snake
            

    def extraction_tuple(self,liste_a_trier):
        u = []
        for element in liste_a_trier:
            
            if len(element) ==2 :
                for liste in element:
                    for tuples in liste:
                        u.append(tuples)
            else:
                for tuples in element:
                    u.append(tuples)
        #print("u a cette forme :",u)
        #print("longueur attendue ", len(u))
        return u
    
    
    def reformatage(self,rattache):
        coordinates_final = []
        for iti in rattache[0]:
            coordinates_final.append(iti)
        for itou in rattache[1]:
            coordinates_final.append(itou)
            
            #Test propreté des itinéraires
            for i in coordinates_final:
                for j in i:
                    if type(j) == list:
                        print("ca va pas")
                        print(j)
        print("coordonnées telles qu'elles vont rentrerdans la multiple_to_one et qui sont correctes",coordinates_final)
        print("longueur totale de ces coordonnées",len(coordinates_final))
        for element in coordinates_final:
            print("longueur de l'itinéraire : ", len(element))
        return coordinates_final
    
    def re_etoffement(self, troncons, polyligne):
        print("notre couche de troncon : ", len(troncons))
        print("notre couche avec une polyligne : ", len(polyligne))
        troncon_formate_pour_recollage = []
        for element in troncons:
            noeud_sale_dep = element[0]
            noeud_sale_arr = element[1]
            noeud_propre_dep= (noeud_sale_dep[0],noeud_sale_dep[1])
            noeud_propre_arr = (noeud_sale_arr[0],noeud_sale_arr[1])
            troncon_formate_pour_recollage.append(noeud_propre_dep)
            troncon_formate_pour_recollage.append(noeud_propre_arr)
        #print("les troncons recolléss bien tout plein", troncon_formate_pour_recollage)
        final = []
        for i in range(len(polyligne) -1):
            noeud_previous = polyligne[i]
            noeud_after = polyligne[i+1]
            if noeud_previous in troncon_formate_pour_recollage and noeud_after in troncon_formate_pour_recollage:
                #print("hello")
                idx1 =troncon_formate_pour_recollage.index(noeud_previous) 
                idx2 = troncon_formate_pour_recollage.index(noeud_after)
                debut = min(idx1, idx2)
                fin = min(idx1, idx2)
                indexes_entre_tuples = list(range(debut + 1, fin))
                final.append(noeud_previous)
                for a in indexes_entre_tuples:
                    final.append(troncon_formate_pour_recollage[a])
                final.append(noeud_after)
        
        #print("alors le final ?", final)
        print("len", len(final))
        return final