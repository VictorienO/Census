# -*- coding: utf-8 -*-
"""
/***************************************************************************
 Census
                                 A QGIS plugin
 Ce plugin permet de définir un parcours optimal sur une zone définie par l'utilisateur dasn un contexte de recensement dans des zones où les données sont moindres
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2023-06-16
        git sha              : $Format:%H$
        copyright            : (C) 2023 by Victorien OLLIVIER
        email                : victorien.ollivier@ensg.eu
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
from qgis.PyQt.QtCore import QSettings, QTranslator, QCoreApplication
from qgis.PyQt.QtGui import QIcon,QColor
from qgis.PyQt.QtWidgets import QAction, QFileDialog, QTextEdit, QDialog, QVBoxLayout, QDialogButtonBox, QLineEdit, QLabel, QMessageBox

# Initialize Qt resources from file resources.py
from .resources import *
# Import the code for the dialog
from .Census_dialog import CensusDialog
import os.path
from qgis.core import *
import processing
import networkx as nx
from networkx.algorithms import approximation
import random
from PyQt5.QtCore import QVariant
from qgis.utils import iface
#from qgis._core import QgsDistanceArea, QgsEllipsoid

#import qgis.core.QgsPalLayerSettings
#from qgis.core import QgsPalLayerSettings
#from qgis.core import QgsLabeling, QgsLabelAttribute, QgsExpression, QgsLinePlacement, QgsMarkerSymbol, QgsSingleSymbolRenderer
#from qgis.gui import QgsCurveArrowSymbolLayer
#from qgis.core import QgsVectorLayer, QgsProject,QgsFeature, QgsExpression, QgsFeatureRequest, QgsVectorLayerUtils

class Census:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        self.iface = iface
        self.plugin_dir = os.path.dirname(__file__)
        self.menu = self.tr(u'&Census')
        self.first_start = None
        self.actions = []

    def tr(self, message):
        return QCoreApplication.translate('Census', message)

    def add_action(self, icon_path, text, callback):
        icon = QIcon(icon_path)
        action = QAction(icon, text, self.iface.mainWindow())
        action.triggered.connect(callback)
        self.iface.addToolBarIcon(action)
        self.actions.append(action)
        return action

    def initGui(self):
        icon_path = ':/plugins/Census/icon.png'
        self.add_action(icon_path, text=self.tr(u'Census'), callback=self.run)
        self.first_start = True

    def unload(self):
        for action in self.actions:
            self.iface.removeToolBarIcon(action)

    def select_output_file(self, line_edit):
        dialog = QFileDialog()
        dialog.setFileMode(QFileDialog.ExistingFile)
        dialog.setNameFilter("Shapefile (*.shp)")
        if dialog.exec_():
            filenames = dialog.selectedFiles()
            if filenames:
                filename = filenames[0]
                line_edit.setText(filename)

    def run(self):
        if self.first_start:
            self.first_start = False
            self.dlg = CensusDialog()

            self.dlg.pushShpRoads.clicked.connect(lambda: self.select_output_file(self.dlg.lineShpRoads))
            self.dlg.pushShpHydro.clicked.connect(lambda: self.select_output_file(self.dlg.lineShpHydro))
            self.dlg.pushShpZone.clicked.connect(lambda: self.select_output_file(self.dlg.lineShpZone))

        # show the dialog
        self.dlg.show()
        # Run the dialog event loop
        result = self.dlg.exec_()
        # See if OK was pressed
        if result:
            shp_roads_path = self.dlg.lineShpRoads.text()
            shp_hydro_path = self.dlg.lineShpHydro.text()
            shp_zone_path = self.dlg.lineShpZone.text()
            
            # Check shapefile validity
            if not self.is_valid_shapefile(shp_roads_path):
                return
            if not self.is_valid_shapefile(shp_hydro_path):
                return
            if not self.is_valid_shapefile(shp_zone_path):
                return
            
            self.process_shapefiles(shp_roads_path, shp_hydro_path, shp_zone_path)

    def is_valid_shapefile(self, shp_path):
        layer = QgsVectorLayer(shp_path, "Validation Layer", "ogr")
        if not layer or not layer.isValid():
            QMessageBox.warning(
                self.iface.mainWindow(),
                "Validation Error",
                "The file \"%s\" is not a valid shapefile." % shp_path.replace(':', os.sep)
                )
            return False
        return True
    

    def process_shapefiles(self, shp_roads_path, shp_hydro_path, shp_zone_path):
        Z_layer, R_layer, H_layer = self.plot_couches_entrees(shp_roads_path, shp_hydro_path, shp_zone_path)
        #Z_layer, R_layer, H_layer = self.reduction_donnees_au_necessaire(shp_roads_path,shp_hydro_path,shp_zone_path)
        #T_layer = self.explosion_des_routes(R_layer)
        T_layer = R_layer
        #QgsProject.instance().addMapLayer(T_layer)
        arretes = self.creation_arrete(T_layer)
        G_zone = self.creation_graphe(arretes)
      #  grouph = self.draw_graph(G_zone)
        itineraire, solution = self.meilleur_glouton(G_zone, 1000)
        
        clean_parcours_zone = self.coordonnees_formatees(itineraire)
        
        first_tri = self.iti_petit_grand_tri(clean_parcours_zone)
        apres_premier_rattachement = self.iti_mignon_oust(G_zone, first_tri[0], first_tri[1])
        remise_en_forme = self.reformatage(apres_premier_rattachement)
        tryingsmth = self.plot_itineraries_when_multiple(remise_en_forme)
        snake = []
        last_iti = self.multiples_to_one(G_zone, remise_en_forme, snake, remise_en_forme[0])
        couche_finish = self.extraction_tuple(last_iti)
        
        #couche_sur_troncon = self.re_etoffement( arretes, couche_finish)
        #couche_sur_troncon = self.re_etoffement_tes(T_layer, couche_finish)
        # #print("couchefinale bien formatée sa mère", couche_finish)
        couche_iti = self.plot_arrow_polyline(couche_finish)
        return couche_iti
     
    def plot_couches_entrees(self,shp_roads_path, shp_hydro_path, shp_zone_path): # Cette fonction est opérationnelle et est commentée.
        """
        Fonction qui prend en entrée les chemins d'accès aux couches sélectionnées
        par l'utilisateur et qui les représente sur QGIS, et  qui ressort les couches vectorielles. 

        Parameters
        ----------
        shp_roads_path : String
            Chemin d'accès à la couche routes
        shp_hydro_path : String
            Chemin d'accès à la couche hydrographie
        shp_zone_path : String
            Chemin d'accès à la couche zone

        Returns
        -------
        zone_layer, roads_layer, hydro_layer : QgsVectorLayer
            Couches QGIS construites.

        """
        hydro_layer = QgsVectorLayer(shp_hydro_path, "Hydrographie", "ogr")
        zone_layer = QgsVectorLayer(shp_zone_path, "Zone", "ogr")
        roads_layer = QgsVectorLayer(shp_roads_path, "Routes", "ogr")
        #QgsProject.instance().addMapLayer(hydro_layer)
        QgsProject.instance().addMapLayer(zone_layer)
        QgsProject.instance().addMapLayer(roads_layer)
        return zone_layer, roads_layer, hydro_layer

    def reduction_donnees_au_necessaire(self, shp_roads_path, shp_hydro_path, shp_zone_path): # En cours
        zone_layer = QgsVectorLayer(shp_zone_path, "Zone", "ogr")
        roads_layer = QgsVectorLayer(shp_roads_path, "Routes", "ogr")
        hydro_layer = QgsVectorLayer(shp_hydro_path, "Hydrographie", "ogr")
        
        if not roads_layer.isValid() or not zone_layer.isValid():
            print("Erreur lors du chargement des couches.")
        else:
            # Effectuer la sélection par expression
            expression = f'intersects($geometry, geometry(get_feature(\'{zone_layer.name()}\', 1)))'
            roads_layer.selectByExpression(expression, QgsVectorLayer.SetSelection)
            
            # Créer une nouvelle couche avec les entités sélectionnées
            layer_resultat = QgsVectorLayer("LineString?crs=epsg:4326", "Résultat", "memory")
            layer_resultat.dataProvider().addFeatures([f for f in roads_layer.selectedFeatures()])
        
        # Ajouter la couche résultat à la carte
            QgsProject.instance().addMapLayer(layer_resultat)
        
        QgsProject.instance().addMapLayer(zone_layer)
        QgsProject.instance().addMapLayer(hydro_layer)
        
        return zone_layer, layer_resultat, hydro_layer

    def explosion_des_routes(self, road_layer): # Cette fonction est opérationnelle et est commentée.
        """
        Fonction qui permet de passer des entités "routes" aux tronçons qui les composent,
        et donc de prendre en compte la totalité des noeuds nécessaires à la modélisation
        du réseau en graphe, prenant en compte les interesections de routes non
        explicites dans les données "routes"

        Parameters
        ----------
        road_layer : QgsVectorLayer
            Couche QGIS qui stocke toutes les données routières 

        Returns
        -------
        features_troncons : QgsVectorLayer
            Couche QGIS qui stocke tous les tronçons de chaque route.

        """
        
        # Spécifie le chemin vers le fichier de sortie pour les lignes explosées, à demander à l'utilisateur.
        output_layer = 'C:/Users/Myriam/Documents/IT2/stage/la_couche_sortie.shp'

        # Utilisation du processing pour exploser les lignes
        parameters = {'INPUT': road_layer, 'OUTPUT': output_layer, 'OVERWRITE': True}
        processing.run('qgis:explodelines', parameters)

        # Création et représentation de la couche des routes explosées sur QGIS
        explode_layer = QgsVectorLayer(output_layer, "Troncons", "ogr")
        QgsProject.instance().addMapLayer(explode_layer)
        # if not explode_layer.isValid():
        #     print("Layer failed to load!")
        # else:
        #     QgsProject.instance().addMapLayer(explode_layer)
        
        # Récupération des features de la couche, sortie
        
        features_troncons = explode_layer.getFeatures()
        
        return features_troncons
    
    def creation_arrete(self, troncons): # Cette fonction est opérationnelle et est commentée.
        """
        Fonction qui prend en entrée les tronçons du réseau routier et qui ramène
        les arretes nécessaires, afin que chaque arrete représente une portion de route,
        mais que l'on puisse prendre en compte les intersections dans le graphe.

        Parameters
        ----------
        troncons : features
            Features de la couche QGIS qui stocke toutes les troncons 

        Returns
        -------
        arretes : list
            Liste de deux tuples, paire de noeud.

        """
        troncons_layer = troncons.getFeatures()
        
        arretes = []
        id1 = 0
        
        # Boucle de tri pour conserveruniquement les noeuds de départ, d'arrivée et d'intersection des routes. 
        for feature in troncons_layer:
            geometry = feature.geometry()
            multi_line = geometry.asMultiPolyline()
            id1 = feature.attribute("osm_id")
            id2 = 0
            for line in multi_line:
                start_point = [line[0][0], line[0][1], feature.id()]
                end_point = [line[-1][0], line[-1][1], feature.id()]
                id2 = id2 + 1
                formatted_line = [start_point, end_point,id1,id2]
                # On stocke nos arretes dans une liste
                arretes.append(formatted_line)
        
        return arretes
    
    def creation_graphe(self, arretes_de_zone): # Cette fonction est opérationnelle et est commentée.
        """
        Fonction qui prend en entrée les arretes qui représentent le réseau routier au mieux, et
        qui ressort un graph, une modélisation avec noeuds (nodes) et arretes (edges)

        Parameters
        ----------
        arretes_de_zone : liste
            Liste de liste de tuples, qui sont les arretes (paires de noeuds)

        Returns
        -------
        G : networkx.graph
            Le graphe qui modélise le réseau routier.

        """
        
        
        # Initialisation d'un graphe
        G = nx.Graph()
        target_crs = QgsCoordinateReferenceSystem('EPSG:32632')  # Exemple: UTM Zone 32N, correspondant au Nigeria

    # Créer l'objet QgsCoordinateTransform pour la transformation des coordonnées
        transform = QgsCoordinateTransform(QgsCoordinateReferenceSystem('EPSG:4326'), target_crs, QgsProject.instance())
        
        # Construction du graphe et remplissage
        for start_point, end_point, id1, id2 in arretes_de_zone:
            start_node = tuple(start_point[:2])
            end_node = tuple(end_point[:2])
            edge_label = f"{id1}_{id2}"  # Étiquette de l'arête
            start_point_proj = transform.transform(QgsPointXY(start_node[0], start_node[1]))
            end_point_proj = transform.transform(QgsPointXY(end_node[0], end_node[1]))
            distance = start_point_proj.distance(end_point_proj)
            # Ajout des nœuds et l'arête au graphe
            G.add_node(start_node)
            G.add_node(end_node)
            G.add_edge(start_node, end_node, label=edge_label, weight=distance)

        # Identification des nœuds inutiles
        modified = True
        
        while modified:
            modified = False
            
            for node in list(G.nodes()):
                neighbors = list(G.neighbors(node))
                
                if len(neighbors) == 2:
                    arretes_voisines = []
                    poids = []
                    for voisin in neighbors:
                        edge_label = G.edges[node, voisin]['label']
                        arretes_voisines.append(edge_label)
                        edge_point = G.edges[node,voisin]['weight']
                        poids.append(edge_point)
                    label1 = arretes_voisines[0]
                    label2 = arretes_voisines[1]
                    
                    if label1 == label2:
                        
                        # On définit le nouveau poids
                        weight_redefini = sum(poids)
                
                        # On retire les noeuds inutiles et on reconstruit l'arrete.
                        G.remove_node(node)
                        G.add_edge(neighbors[0], neighbors[1], label=label1, weight=weight_redefini) #attention, le poids devra etre une pondération
                        modified = True
                        break
        testkm = []
        for start_node, end_node, edge_data in G.edges(data=True):
            weight = edge_data['weight']
            testkm.append(weight)
            
        print("la taille du graphe en mètre : ", sum(testkm))


        return G

    def chemin_optimal(self, graph,passed_edges,passed_nodes, nombre_true,poids_total_parcouru, noeud_depart): # Cette fonction est opérationnelle et est commentée.
        """
        Fonction qui implémente un algorithme glouton, qui construit des itinéraire. L'algorithme est "aveugle"
        et raisonne donc sur une logique de PPV, avec une considération des poids et du statut des arêtes voisines
        d'un noeud. Il s'agit d'un algorithme récursif, qui créé donc plusieurs itinéraires optimaux.

        Parameters
        ----------
        graph : networkx.graph
            Graphe modélisant le réseau routier de la zone étudiée.
        passed_edges : list
            Liste d'arêtes, qui construisent l'itinéraire (dès que l'on passe par une arête, elle est ajoutée à cette liste)
        passed_nodes : liste
            Liste de noeuds, idem que passed_edges
        nombre_true : int
            Nombred'arêtes avec le statut "visited"
        poids_total_parcouru : int
            Poids total parcouru au cours de l'itinéraire
        noeud_depart : networkx.nodes
            Noeud de départ, peut être aléatoire ou choisi à l'initialisation, est aléatoire parmi les noeuds non-visités lors de la récursivité.

        Returns
        -------
        passed_edges : list
            Liste d'arêtes, qui construisent l'itinéraire (dès que l'on passe par une arête, elle est ajoutée à cette liste)
        poids_total_parcouru : int
            Poids total parcouru au cours de l'itinéraire

        """
        nombre_edges = graph.number_of_edges() # On récupère le nombre d'arêtes du graphe
        if nombre_true >= nombre_edges:# Condition d'arrêt : toutes les arêtes sont visitées. 
            return passed_edges, poids_total_parcouru
        liste_noeuds_libres = []
        
        for node in list(graph.nodes()):
            neighbors = list(graph.neighbors(node))
            for voisin in neighbors:    
                if graph.edges[node, voisin]['Visited'] == False:
                    liste_noeuds_libres.append(node)
                    break
        if noeud_depart == 0:
            if len(liste_noeuds_libres) > 0:
                start_node = liste_noeuds_libres[0]
                passed_nodes.append(start_node)
            else:
                print("ERROR")
        else:
            start_node = noeud_depart
            
            
        graph.nodes[start_node]['Visited'] = True
        

        passed_nodes.append(start_node)
        
        # Tant que on a pas tout parcouru une fois, on continue
        while nombre_true < nombre_edges:

            noeud_ou_nous_sommes = passed_nodes[-1]
            
            voisins_du_noeud_ou_nous_sommes = list(graph.neighbors(noeud_ou_nous_sommes))
            
            if len(voisins_du_noeud_ou_nous_sommes) == 1:
                #DEGREE 1
                # Dans ce cas de figure, on est en bout d'arrete et il n'y a pas de voisins, il faut faire demi-tour
                
                noeud_suivant = voisins_du_noeud_ou_nous_sommes[0]
                
                graph.nodes[noeud_suivant]['Visited'] = True
                if graph.edges[noeud_ou_nous_sommes,noeud_suivant]['Visited'] ==False:
                    nombre_true +=1
                    graph.edges[noeud_ou_nous_sommes,noeud_suivant]['Visited'] =True
                else:
                    graph.edges[noeud_ou_nous_sommes,noeud_suivant]['Visited'] =True
                poids_total_parcouru += graph.edges[noeud_ou_nous_sommes,noeud_suivant]['weight']
                passed_nodes.append(noeud_suivant)
                passed_edges.append((noeud_ou_nous_sommes, noeud_suivant))
            
            else:
                arretes_pas_visites=[]
            
                for noeud in voisins_du_noeud_ou_nous_sommes:
                    arrete = graph.edges[(noeud_ou_nous_sommes,noeud)]
                    if arrete['Visited'] == False:
                        arretes_pas_visites.append([arrete, noeud_ou_nous_sommes, noeud])
                
                if len(arretes_pas_visites)>=2 :
                    #DEGREE 1
                    poids = []
                    for arrete in arretes_pas_visites:
                        poids.append(arrete[0]['weight'])
                    idx_min_poids = poids.index(min(poids))
                    arrete_plus_petit_poids = arretes_pas_visites[idx_min_poids]
                    noeud1 = arrete_plus_petit_poids[1]
                    noeud2 = arrete_plus_petit_poids[2]
                    noeud_suivant = noeud2
                    graph.nodes[noeud_suivant]['Visited'] = True
                    graph.edges[noeud1, noeud_suivant]['Visited'] = True
                    nombre_true+=1
                    poids_total_parcouru += graph.edges[noeud1,noeud_suivant]['weight']
                        
                    passed_nodes.append(noeud_suivant)
                    passed_edges.append((noeud1, noeud_suivant))
                    
                elif len(arretes_pas_visites) == 1 :
                    arrete = arretes_pas_visites[0]
                    
                    noeud1 = arrete[1]
                    noeud2 = arrete[2]
                    
                    noeud_suivant = noeud2
                    graph.nodes[noeud_suivant]['Visited'] = True
                    graph.edges[noeud1, noeud_suivant]['Visited'] = True
                    
                    passed_nodes.append(noeud_suivant)
                    passed_edges.append((noeud1, noeud_suivant))
                    nombre_true+=1
                    poids_total_parcouru += graph.edges[noeud1,noeud_suivant]['weight']
                        
                
                else:
                    #On est dans la situation suivante : il y a plus d'un voisin. Ils sonttous visités
                    #print("cas pas facile en approche")
                    
                    liste_noeuds_voisins_libres = []
                    for noeud in voisins_du_noeud_ou_nous_sommes:
                        
                     #   print("ok, on rentre dans la boucle 158")
                      #  arrete_visitees = graph.edges[(noeud_ou_nous_sommes,noeud)]
                        les_voisins_du_voisin = list(graph.neighbors(noeud))
                      #  print("les voisins du voisin", les_voisins_du_voisin)
                        for voisinvoisin in les_voisins_du_voisin:
                       #     print("on cherche si les arretes sont false a degree 2")
                            if graph.edges[noeud, voisinvoisin]['Visited'] == False:
                                edge_cas_degree_deux = graph.edges[(noeud_ou_nous_sommes,noeud)]
                                liste_noeuds_voisins_libres.append([edge_cas_degree_deux,noeud_ou_nous_sommes, noeud])
                        #        print("la liste est elle remplie ?", liste_noeuds_voisins_libres)
                                
                    
                    if len(liste_noeuds_voisins_libres) > 0:
                        #print("bon alors ca arrive !")
                        arrete = liste_noeuds_voisins_libres[0]
                     #   print("arretes  l123 : ", arrete)
                        
                        noeud1 = arrete[1]
                        noeud2 = arrete[2]
                        
                        noeud_suivant = noeud2
                        graph.nodes[noeud_suivant]['Visited'] = True
                        graph.edges[noeud1, noeud_suivant]['Visited'] = True
                        
                        passed_nodes.append(noeud_suivant)
                        passed_edges.append((noeud1, noeud_suivant))
                        poids_total_parcouru += graph.edges[noeud1,noeud_suivant]['weight']
                    
                    else :
                        liste_noeuds_voisins_voisins_libres = []
                        for noeud in voisins_du_noeud_ou_nous_sommes:
                            les_voisins_du_voisin = list(graph.neighbors(noeud))
                            for cousin in les_voisins_du_voisin:
                                cousincousin = list(graph.neighbors(cousin))
                                for indiv in cousincousin:
                                    if graph.edges[cousin, indiv]['Visited'] == False:
                                        edges_cas_degree_trois = graph.edges[(noeud_ou_nous_sommes, noeud)]
                                        liste_noeuds_voisins_voisins_libres.append([edges_cas_degree_trois,noeud_ou_nous_sommes,noeud])
                        
                        
                        if len(liste_noeuds_voisins_voisins_libres) > 0:
                            arrete = liste_noeuds_voisins_voisins_libres[0]
                            noeud1 = arrete[1]
                            noeud2 = arrete[2]
                            noeud_suivant = noeud2
                            graph.nodes[noeud_suivant]['Visited'] = True
                            graph.edges[noeud1, noeud_suivant]['Visited'] = True
                            passed_nodes.append(noeud_suivant)
                            passed_edges.append((noeud1, noeud_suivant))
                            poids_total_parcouru += graph.edges[noeud1,noeud_suivant]['weight']
                            
                        
                        else:
                            liste_noeuds_voisin_degre4 = []
                            for noeud in voisins_du_noeud_ou_nous_sommes:
                                les_voisins_du_voisins = list(graph.neighbors(noeud))
                                for cousin in les_voisins_du_voisins:
                                    cousincousin = list(graph.neighbors(cousin))
                                    for indiv in cousincousin:
                                        voisinsdeg4 = list(graph.neighbors(indiv))
                                        for individu in voisinsdeg4:
                                            if graph.edges[indiv,individu]['Visited'] ==False:
                                                edges_cas_degree_quatre = graph.edges[(noeud_ou_nous_sommes, noeud)]
                                                liste_noeuds_voisin_degre4.append([edges_cas_degree_quatre,noeud_ou_nous_sommes,noeud])
                            if len(liste_noeuds_voisin_degre4) > 0:
                                arrete = liste_noeuds_voisin_degre4[0]
                                noeud1 = arrete[1]
                                noeud2 = arrete[2]
                                noeud_suivant = noeud2
                                graph.nodes[noeud_suivant]['Visited'] = True
                                graph.edges[noeud1, noeud_suivant]['Visited'] = True
                                passed_nodes.append(noeud_suivant)
                                passed_edges.append((noeud1, noeud_suivant))
                                poids_total_parcouru += graph.edges[noeud1,noeud_suivant]['weight']
                                
                            else:
                                # Récursivité : il n'y a aucune arête assez à proximité, on relance l'algorithme à partir d'un autre point. 
                                return self.chemin_optimal(graph, passed_edges,passed_nodes, nombre_true,poids_total_parcouru, 0)
        return passed_edges, poids_total_parcouru
    
    def tri_itineraires(self,chemin): # Cette fonction est opérationnelle et est commentée.
        """
        Fonction qui permet de passer des paires de noeuds à des polylignes

        Parameters
        ----------
        chemin : list
            Liste dont les données sont organisées en paires de noeuds (pour chaque arête) 

        Returns
        -------
        les_chemins : list
            Liste qui fonctionne en terme de noeuds, pas en paires. C'est une polyligne. 

        """
        
        les_chemins = []  # Liste pour stocker les itinéraires
        chemin_temporaire = []  # Liste temporaire pour un itinéraire courant

        for troncon in chemin:
            if len(chemin_temporaire) == 0:
                chemin_temporaire.append(troncon)
            else:
                dernier_troncon = chemin_temporaire[-1]
                noeud_fin_dernier = dernier_troncon[1]
                noeud_debut_actuel = troncon[0]

                if noeud_fin_dernier == noeud_debut_actuel:
                    chemin_temporaire.append(troncon)
                else:
                    les_chemins.append(chemin_temporaire)
                    chemin_temporaire = [troncon]

        if len(chemin_temporaire) > 0:
            les_chemins.append(chemin_temporaire)

        return les_chemins
    
    def meilleur_glouton(self,G,nombre_de_relance): # Cette fonction est opérationnelle et est commentée.
        """
        Fonction qui permet de lancer l'algorithme glouton (chemin_optimal, tri_itineraires) plusieurs fois et de comparer les
        résultats de chacun pour choisir le plus optimal.

        Parameters
        ----------
        G : networkx.graph
            graphe modélisant le réseau routier.
        nombre_de_relance : int
            Nombre de fois que l'utilisateurs souhaite lancer l'algorithme glouton. 

        Returns
        -------
        itineraire_final : list
            Liste avec chaque itinéraire construit, sous forme de polyligne
        solution : list
            Liste avec chaque itinéraire construit, sous forme de liste de paires de noeuds, de polylignes, avec le nombre d'itinéraires, le coût total parcouru, l'indice d'optimalité.
        """
        
        liste_infos_pour_chaque_iti = []
        
        for i in range(nombre_de_relance): # On réalise n fois le protocole suivant :
            
            # Initialisation 
            nx.set_node_attributes(G, False, 'Visited')
            nx.set_edge_attributes(G, False, 'Visited')
            poids_total_parcouru = 0
            noeud_depart = random.choice(list(G.nodes())) # On initialise un noeud de départ. Il est ici au hasard, il peut être demandé à l'utilisateur.
            passed_edges = []
            passed_nodes = []
            nombre_true = 0
            
            # Lancement des algorithmes de parcourt optimal
            A = self.chemin_optimal(G, passed_edges,passed_nodes,nombre_true,poids_total_parcouru, noeud_depart)
            B = self.tri_itineraires(A[0])
            nombre_iti = len(B) # On récupère le nombre d'itinéraires créés lors de l'itération. 
            poids_de_la_relance = A[1] # On récupère le poids total parcour lors de l'itération.

            # Définition de l'indice d'optimalité, qu'on souhaite minimiser.
            alpha = 0.85
            beta = 0.15
            indice_optimalite = alpha * nombre_iti + beta * poids_de_la_relance
            liste_infos_pour_chaque_iti.append([A, B, nombre_iti, poids_de_la_relance, indice_optimalite])
        
        # On cherche l'itinéraire qui a l'indice d'optimalité le plus faible, c'est-à-dire qui minimise le nombre de portions d'itinéraire, ainsi que le coût total. 
        R_min = []
        for iti_possible in liste_infos_pour_chaque_iti:
            R_min.append(iti_possible[-1])
        
        minimum = min(R_min)
        index_minimum = R_min.index(minimum)
        
        # On prépare le return, qui ressort les informations sur le meilleur itinéraire. 
        solution = liste_infos_pour_chaque_iti[index_minimum]
        print("le nombre de metres parcouru est : ", solution[3])
        itineraire_final = solution[1]
        
        return itineraire_final, solution
    
    def coordonnees_formatees(self,solution): # Cette fonction est opérationnelle et fonctionne.
        """
        Fonction qui prend en entrée les arretes itinéraires optimaux et qui les formate pour préparer
        un premier rattachement (par le biais d'une distinction entre les petits et grands itinéraires).

        Parameters
        ----------
        solution : list
            Liste en bazard des itinéraires optimaux. 

        Returns
        -------
        coordinates_propre : list
            Liste propre de ce qui va permettre de les classer entre petits et grands itinéraires. 

        """
        coordinates_propre = []
        for iti in solution :
            iti_propre = []
            for arrete in iti:
                iti_propre.append(arrete[0])
            iti_propre.append(iti[-1][1])
            coordinates_propre.append(iti_propre)
        return coordinates_propre
    
    def plot_itineraries_when_multiple(self,coo): # Cette fonction est opérationnelle et est commentée.
        """
        Fonction qui permet de représenter les itinéraires optimaux sur une zone, avant que ceux-ci ne
        soient rattachés entre eux. Elle ne retourne rien puisqu'il s'agit d'une fonction de visualisation.

        Parameters
        ----------
        coo : List
            Liste de listes : chaque sous-liste est un itinéraire construit par les fonctions précédentes.

        Returns
        -------

        """
        for index, polyligne in enumerate(coo): # On parcourt chaque itinéraire optimal créé, on en fait une couche, et on la représente sur QGIS. 
            layer = QgsVectorLayer('LineString?crs=epsg:4326', f'Itineraire_{index}', 'memory')
            points = [QgsPointXY(*coord) for coord in polyligne]
            line = QgsGeometry.fromPolylineXY(points)
            feature = QgsFeature()
            feature.setGeometry(line)
            layer.dataProvider().addFeature(feature)
            QgsProject.instance().addMapLayer(layer)
        
    def plot_arrow_polyline(self, polyligne): # Cette fonction est opérationnelle et est commentée.
        """
        Fonction qui permet de configruer la visualisation et représenter l'itinéraire final. Elle ne
        return rien, il ne s'agit que de visualisation.

        Parameters
        ----------
        polyligne : List
            Liste de tuples : c'est l'itinéraire final ordonné

        Returns
        -------

        """
        points = [QgsPointXY(x[0], x[1]) for x in polyligne]
        
        # Création de la polyligne à partir des points
        polyline = QgsGeometry.fromPolylineXY(points)
        
        # Création d'une couche vectorielle pour stocker les segments de la polyligne
        layer = QgsVectorLayer("LineString?crs=EPSG:4326", "Itinéraire", "memory")
        provider = layer.dataProvider()
        
        # Définir les champs de la couche
        provider.addAttributes([QgsField("rang", QVariant.Int)])
        
        # Ajouter les entités et les attributs
        features = []
        for i in range(len(points) - 1):
            segment_start = points[i]
            segment_end = points[i + 1]
            
            # Création d'une entité pour le segment avec le rang attribué
            segment_feature = QgsFeature()
            segment_geometry = QgsGeometry.fromPolylineXY([segment_start, segment_end])
            segment_feature.setGeometry(segment_geometry)
            segment_feature.setAttributes([i + 1])  # Attribution du rang (index + 1)
            
            features.append(segment_feature)
            
            # Ajout des entités à la couche
        provider.addFeatures(features)
        
        layer.updateFields()
        layer.updateExtents()
        
        # Définition du style de symbologie pour les flèches
        symbol_layer = QgsArrowSymbolLayer()
        #symbol_layer.setFillColor(QColor(255, 0, 0))  # Couleur de remplissage de la flèche
        
        line_symbol = QgsLineSymbol()
        line_symbol.setWidth(0.6)  # Épaisseur du contour de la flèche
        line_symbol.changeSymbolLayer(0, symbol_layer)
        
        # Définition du rendu de symboles unique
        renderer = QgsSingleSymbolRenderer(line_symbol)
        layer.setRenderer(renderer)
        
        # Ajout de la couche à la carte
        QgsProject.instance().addMapLayer(layer)

    def draw_graph(self,G): # Non lancée dans le plugin
        
        #FONCTIONNE, enfin pas vraiment, probleme avec la création du canva...
        
    # Créer une nouvelle couche vectorielle pour les nœuds du graphe
        layer_nodes = QgsVectorLayer("Point?crs=EPSG:4326", "Nodes", "memory")
        layer_nodes.startEditing()
        layer_nodes.addAttribute(QgsField("node_id", QVariant.Int))

    # Ajouter les nœuds au layer_nodes
        for i, node in enumerate(G.nodes()):
            feature = QgsFeature()
            point = QgsPointXY(*node)
            feature.setGeometry(QgsGeometry.fromPointXY(point))
            feature.setAttributes([i+1])  # Utilisation d'identifiants uniques pour les nœuds
            layer_nodes.addFeature(feature)

        layer_nodes.commitChanges()

    # Ajouter le layer_nodes à QgsProject
        QgsProject.instance().addMapLayer(layer_nodes)

    # Créer une nouvelle couche vectorielle pour les arêtes du graphe
        layer_edges = QgsVectorLayer("LineString?crs=EPSG:4326", "Edges", "memory")
        layer_edges.startEditing()
        layer_edges.addAttribute(QgsField("edge_id", QVariant.Int))

    # Ajouter les arêtes au layer_edges
        for i, edge in enumerate(G.edges()):
            start_node, end_node = edge
            start_point = QgsPointXY(*start_node)
            end_point = QgsPointXY(*end_node)
            feature = QgsFeature()
            feature.setGeometry(QgsGeometry.fromPolylineXY([start_point, end_point]))
            feature.setAttributes([i+1])  # Utilisation d'identifiants uniques pour les arêtes
            layer_edges.addFeature(feature)

        layer_edges.commitChanges()

    # Ajouter le layer_edges à QgsProject
        QgsProject.instance().addMapLayer(layer_edges)

    # Créer un canvas pour afficher la carte
        canvas = QgsMapCanvas()
        canvas.setDestinationCrs(layer_nodes.crs())
        canvas.setLayers([layer_nodes, layer_edges])
        canvas.zoomToFullExtent()

    # Afficher la carte dans la fenêtre de QGIS
        return canvas.show()
    
    def iti_petit_grand_tri(self,liste_de_liste): # Cette fonction est opérationnelle et est commentée.
        """
        Fonction qui permet de trier les itinéraires : les plus petits et les plus grands

        Parameters
        ----------
        liste_de_liste : List
            Liste de listes : chaque sous-liste est un itinéraire construit par les fonctions préalables.

        Returns
        -------
        petits_iti : List
            Liste de liste avec chaque liste étant un petit itinéraire.
        grands_iti : List
            Liste de liste avec chaque liste étant un grand itinéraire.

        """
        petits_iti = []
        grands_iti = []
        for liste in liste_de_liste:
            if len(liste) <20: # On décide du seuil pour définir un petit itinéraire. Ici, c'est 20 noeuds la limite. 
                petits_iti.append(liste)
                
            else:
                grands_iti.append(liste)
        
        return petits_iti, grands_iti
    
    def iti_mignon_oust(self,graph, petit_iti, grand_iti): # Cette fonction est opérationnelle et est commentée.
        """
        Fonction qui sélectionne les petits itinéraires à proximité des grands itinéraires et les
        introduit dans les plus grands. Cela se modélise comme suit : grand_itinéraire(part 1) + petit
        itinéraire (entier) + Dijkstra entre le petit et le grand itinéraire + grand itinéraire (part 2)

        Parameters
        ----------
        graph : networkx.graph()
            Graphe netxorkx qui modélise le réseau routier : chaque arête est une route, chaque noeud une extrémité de route ou une intersection 
        petit_iti : list
            Liste de liste qui contient tous les petits itinéraire de la zone étudiée
        grand_iti : list
            Liste de liste qui contient tous les grands itinéraire de la zone étudiée 

        Returns
        -------
        petit_iti : list
            Liste de listes des petits itinéraires restants (ne correspondant pas aux critères de proximité)
        grand_iti : list
            Liste de listes des grands itinéraires, dont certains ont été modifiés

        """
        
        for petite_liste in petit_iti:
            noeud_depart = petite_liste[0] # On récupère le noeud de départ du petit itinéraire. 
            for grande_liste in grand_iti:
                if noeud_depart in grande_liste: # On vérifie la présence de ce noeud dans l'un des grands itinéraires.
                    noeud_fin = petite_liste[-1] # On récupère le noeud de fin du petit itinéraire.
                    retour_grand_iti = nx.dijkstra_path(graph, noeud_fin, noeud_depart) # On créé le chemin le plus court pour revenir de la fin de l'itinéraire à son début. 
                    for i in range(1, len(retour_grand_iti)):
                        tuple2 = retour_grand_iti[i]
                        petite_liste.append(tuple2) # On créé le petit itinéraire avec un retour à son point de départ.
                    idx_gd_liste = grand_iti.index(grande_liste) # On récupère l'index du grand itinéraire contenant une jonction avec le petit itinéraire.
                    grande_liste_en_question = grand_iti[idx_gd_liste]
                    for i in range(1,len(petite_liste)):
                        grande_liste_en_question.insert(grande_liste_en_question.index(noeud_depart)+i,petite_liste[i]) # On insert à la jonction la boucle de petit itinéraire créée précédement.
                    petit_iti.remove(petite_liste) # On retire des petits itinéraires l'itinéraire rattaché. 
                    break
        return petit_iti, grand_iti
    
    def multiples_to_one(self, graph, liste_coordinates, snake, iti_2): # Cette fonction est opérationnelle et est commentée. 
        """
        Fonction qui permet de créer l'itinéraire final (en terme de points passés) en collant chaque itinéraire
        bout-à-bout en fonction de leur proximité. Elle passe pour cela par une évaluation de la qualité des Dijkstra, d'un point
        d'arrivée d'itinéraire à un point de départ d'un autre. Il s'agit d'une fonction récursive pour permettre
        cette évaluation de toutes les options. 

        Parameters
        ----------
        graph : networkx.graph
            Graphe modélisant le réseau routier de la ville. 
        liste_coordinates : list
            Liste de liste, avec chaque liste un itinéraire optimal.
        snake : list
            Liste de listes qui ordonne les itinéraires de liste_coordinate pour optimiser le parcours total
        iti_2 : list
            Itinéraire à partir duquel on recherche un autre itinéraire, le plus proche.

        Returns
        -------
        snake : list
            Liste de listes avec les itinéraires ordonnés.

        """
        iti = iti_2
        last_point = iti[-1] # On récupère le dernier point de l'itinéraire en question 
        resultat_dijkstra = []
        for i in range(len(liste_coordinates)): # On parcourt les autres itinéraires
            if liste_coordinates[i] != iti : # Si l'itinéraire est différent de celui sur lequel on travaille, 
                premier_point = liste_coordinates[i][1] # On récupère son point de départ
                chemin_rattache = nx.dijkstra_path(graph, last_point, premier_point) # On créé un Dijkstra pour trouver le chemin le plus court entre ces points,
                resultat_dijkstra.append([chemin_rattache, liste_coordinates[i], i]) # On ajoute ce chemin, l'itinéraire en question, son index dans la liste_coordinates dans une liste.
        lengthT = []
        for i in range(len(resultat_dijkstra)): # On parcourt la liste créée
            groupe_d_interet = resultat_dijkstra[i]
            indexx = groupe_d_interet[2] 
            lengh = len(groupe_d_interet[0])
            lengthT.append([lengh, indexx])# On introduit la longueur de chaque Dijkstra.
        
        if len(lengthT) ==0: # Critère d'arrêt, il n'y a plus de voisins ! 
            snake.append(iti)
            return snake
        
        sous_liste_min = min(lengthT, key=lambda x: x[0]) # On récupère le Dijkstra avec le plus petit coût
        idx_plus_petit = sous_liste_min[1]

        for i, item in enumerate(resultat_dijkstra):
            if item[2] == idx_plus_petit:
                index_i = i
                break
        solve = resultat_dijkstra[index_i]
        snake.append([iti, solve[0][1:]]) # On ajoute à snake l'itinéraire parcouru, le dijkstra qui à l'itinéraire le plus proche...
        possibilite = solve[1] # Et on définit notre itinéraire d'intérêt pour la prochaine itération
        liste_coordinates.remove(iti) # On retire l'itinéraire parcouru de la liste_coordinates pour éviter de tourner en boucle. 
        
        return self.multiples_to_one(graph, liste_coordinates, snake, possibilite) # On réappelle la fonction jusqu'au critère d'arrêt. 
            
    def extraction_tuple(self,liste_a_trier): # Cette fonction est opérationnelle et est commentée.
        """
        Fonction qui permet de transformer une liste d'itinéraire non formatée en une liste de tuples.
        Elle considère le cas ou deux sous-listes peuvent avoir été créées au maximum.

        Parameters
        ----------
        liste_a_trier : List
            Liste de listes, de listes de listes, de tuples : elle est mal formatée mais les informations sont chronologiquement correctes. 

        Returns
        -------
        u : List
            Liste de tuples qui consiste en la polyligne final, l'itinéraire ressorti pour la zone étudiée.
        """
        u = []
        for element in liste_a_trier:
            if len(element) ==2 : # Si l'élément à une longueur de deux, alors c'est une liste de deux listes
                for liste in element: # Pour chacune des deux listes...
                    for tuples in liste:
                        u.append(tuples) # ... on ajoute les tuples à u.
            else: # Sinon, l'élément est une liste de tuples
                for tuples in element: # On ajoute les tuples à u.
                    u.append(tuples)
        return u
    
    def reformatage(self,rattache): # Cette fonction est opérationnelle et est commentée.
        """
        Fonction qui condense la liste de deux listes (grands iti et petits iti) en une seule pour la préparer
        à la fonction créant l'itinéraire final.

        Parameters
        ----------
        rattache : List
            Liste de deux listes, avec dans chacune les itinéraires (soit les petis, soit les grands). 

        Returns
        -------
        coordinates_final : List
            Liste de tuples qui consiste en la polyligne final, l'itinéraire ressorti pour la zone étudiée.
        """
        coordinates_final = [] # On ajoute les éléments de chaque liste dans une liste
        for iti in rattache[0]:
            coordinates_final.append(iti)
        for itou in rattache[1]:
            coordinates_final.append(itou)
            
        #Test propreté des itinéraires
        for i in coordinates_final:
            for j in i:
                if type(j) == list:
                    print("Error : your coordinates aren't good")
        return coordinates_final
    
    def re_etoffement(self, troncons, polyligne): # En cours.
        print("notre couche de troncon : ", len(troncons))
        print("notre couche avec une polyligne : ", len(polyligne))
        troncon_formate_pour_recollage = []
        for element in troncons:
            noeud_sale_dep = element[0]
            noeud_sale_arr = element[1]
            noeud_propre_dep= (noeud_sale_dep[0],noeud_sale_dep[1])
            noeud_propre_arr = (noeud_sale_arr[0],noeud_sale_arr[1])
            troncon_formate_pour_recollage.append(noeud_propre_dep)
            troncon_formate_pour_recollage.append(noeud_propre_arr)
        #print("les troncons recolléss bien tout plein", troncon_formate_pour_recollage)
        final = []
        for i in range(len(polyligne) -1):
            noeud_previous = polyligne[i]
            noeud_after = polyligne[i+1]
            if noeud_previous in troncon_formate_pour_recollage and noeud_after in troncon_formate_pour_recollage:
                #print("hello")
                idx1 =troncon_formate_pour_recollage.index(noeud_previous) 
                idx2 = troncon_formate_pour_recollage.index(noeud_after)
                debut = min(idx1, idx2)
                fin = min(idx1, idx2)
                indexes_entre_tuples = list(range(debut + 1, fin))
                final.append(noeud_previous)
                for a in indexes_entre_tuples:
                    final.append(troncon_formate_pour_recollage[a])
                final.append(noeud_after)
        
        #print("alors le final ?", final)
        print("len", len(final))
        return final